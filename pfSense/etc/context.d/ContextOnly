#!/bin/sh
#
# OpenNebula context integration for pfSense
#  - Mounts context CD-ROM and sources context variables
#  - Configures network interfaces based on OpenNebula metadata
#  - Applies additional context settings (SSH keys, DNS, hostname, etc.)
#
PATH=/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin:/root/bin
# shellcheck source=/dev/null
. /etc/rc.subr

name="context"
desc="OpenNebula: context script executor"
# shellcheck disable=SC2034
rcvar="context_enable"

load_rc_config $name
: "${context_enable:=NO}"
# shellcheck disable=SC2034
extra_commands="status stop"

LOG="/var/log/context.log"
CONTEXT_MOUNT="/mnt/context"
CONTEXT_DEV="/dev/cd0"
CONTEXT_FILE="$CONTEXT_MOUNT/context.sh"
XML_FILE="/cf/conf/config.xml"
BACKUP_DIR="/cf/conf/backup"
BACKUP_XML="$BACKUP_DIR/config.xml.$(date +%Y.%m.%d.%H:%M:%S)"

log() {
    echo "$(date) [context] $*" >> "$LOG"
}

mount_context() {
    mkdir -p "$CONTEXT_MOUNT"
    if ! mount | grep -q "on $CONTEXT_MOUNT "; then
        if ! mount -t cd9660 "$CONTEXT_DEV" "$CONTEXT_MOUNT" >> "$LOG" 2>&1; then
            log "failed to mount $CONTEXT_DEV"
            return 1
        fi
        log "mounted $CONTEXT_DEV to $CONTEXT_MOUNT"
    fi
    return 0
}

umount_context() {
    if mount | grep -q "on $CONTEXT_MOUNT "; then
        if umount "$CONTEXT_MOUNT" >> "$LOG" 2>&1; then
            log "unmounted $CONTEXT_MOUNT"
        fi
    fi
}

get_ctx_var() {
    idx="$1"
    suffix="$2"
    val=""
    eval "val=\${ETH${idx}_${suffix}:-}"
    if [ -z "${val:-}" ]; then
        eval "val=\${ETHERNET${idx}_${suffix}:-}"
    fi
    printf '%s' "${val:-}"
}

calc_prefix() {
    mask="$1"
    [ -n "$mask" ] || return 1
    php -r "echo substr_count(decbin(ip2long('$mask')), '1');" 2>/dev/null
}

find_sys_iface() {
    target=$(printf '%s' "$1" | tr '[:upper:]' '[:lower:]')
    [ -n "$target" ] || return 1
    for iface in $(ifconfig -l); do
        mac=$(ifconfig "$iface" | awk '/ether/{print tolower($2)}')
        if [ "$mac" = "$target" ]; then
            echo "$iface"
            return 0
        fi
    done
    return 1
}

ensure_dhcp_node() {
    file="$1"
    if ! xml sel -t -v "count(//dhcpd)" "$file" 2>/dev/null | grep -q '[1-9]'; then
        xml ed -L -s "//config" -t elem -n "dhcpd" -v "" "$file"
    fi
}

configure_network() {
    file="$1"

    wantype=$(printf '%s' "${WANTYPE:-}" | tr '[:upper:]' '[:lower:]')
    lantype=$(printf '%s' "${LANTYPE:-}" | tr '[:upper:]' '[:lower:]')
    dhcp_enabled_list=$(printf '%s' "${DHCPENNABLE:-}" | tr ',;' '\n' | sed 's/[[:space:]]//g' | sed '/^$/d' | tr '[:upper:]' '[:lower:]')

    is_dhcp_enabled() {
        entry=$(printf '%s' "$1" | tr '[:upper:]' '[:lower:]')
        if [ -z "$dhcp_enabled_list" ]; then
            return 1
        fi
        echo "$dhcp_enabled_list" | grep -qx "$entry"
    }

    xml ed -L -d "//interfaces/*" "$file" 2>/dev/null

    ctx_indices=$( (
        env | sed -n 's/^ETH\([0-9][0-9]*\)_MAC=.*/\1/p'
        env | sed -n 's/^ETHERNET\([0-9][0-9]*\)_MAC=.*/\1/p'
    ) | sort -n | uniq )

    if [ -z "$ctx_indices" ]; then
        log "no ETHx_MAC entries provided in context"
        return
    fi

    lan_used=false
    wan_used=false
    opt_index=1
    used_sys_if=""

    for idx in $ctx_indices; do
        ctx_name="eth${idx}"
        ctx_mac=$(get_ctx_var "$idx" "MAC")
        [ -n "$ctx_mac" ] || { log "${ctx_name}: MAC missing"; continue; }

        sys_if=$(find_sys_iface "$ctx_mac")
        if [ -z "$sys_if" ]; then
            log "${ctx_name}: no system interface matches MAC $ctx_mac"
            continue
        fi
        case " $used_sys_if " in
            *" $sys_if "*)
                log "${ctx_name}: system interface $sys_if already processed"
                continue
                ;;
        esac
        used_sys_if="$used_sys_if $sys_if"

        role=""
        desc=""
        if [ "$ctx_name" = "$wantype" ] && [ "$wan_used" = "false" ]; then
            role="wan"
            desc="WAN"
            wan_used=true
        elif [ "$ctx_name" = "$lantype" ] && [ "$lan_used" = "false" ]; then
            role="lan"
            desc="LAN"
            lan_used=true
        else
            role="opt$opt_index"
            desc=$(echo "$role" | tr '[:lower:]' '[:upper:]')
            opt_index=$((opt_index + 1))
        fi

        ip=$(get_ctx_var "$idx" "IP")
        mask=$(get_ctx_var "$idx" "MASK")
        gw=$(get_ctx_var "$idx" "GATEWAY")
        dhcp_start=$(get_ctx_var "$idx" "DHCP_START")
        dhcp_end=$(get_ctx_var "$idx" "DHCP_END")

        mode="dhcp"
        prefix=""
        if [ -n "$ip" ] && [ -n "$mask" ]; then
            prefix=$(calc_prefix "$mask")
            if [ -n "$prefix" ]; then
                mode="static"
            else
                log "${ctx_name}: invalid netmask $mask"
            fi
        fi

        # --- APPLY INTERFACE SETTINGS VIA SYSTEM COMMANDS -------------------
        if [ "$mode" = "static" ]; then
            ifconfig "$sys_if" inet "$ip" netmask "$mask" >> "$LOG" 2>&1
        fi
        ifconfig "$sys_if" ether "$ctx_mac" >> "$LOG" 2>&1
        ifconfig "$sys_if" description "$desc" >> "$LOG" 2>&1
        ifconfig "$sys_if" up >> "$LOG" 2>&1
        if [ "$mode" = "static" ]; then
            log "$sys_if ($ctx_name → $role) set to $ip/$prefix"
        else
            log "$sys_if ($ctx_name → $role) set to DHCP"
        fi
        # -------------------------------------------------------------------

        xml ed -L -d "//interfaces/$role" "$file" 2>/dev/null
        if [ "$mode" = "static" ]; then
            xml ed -L \
                -s "//interfaces" -t elem -n "$role" -v "" \
                -s "//interfaces/$role" -t elem -n "if" -v "$sys_if" \
                -s "//interfaces/$role" -t elem -n "descr" -v "$desc" \
                -s "//interfaces/$role" -t elem -n "enable" -v "" \
                -s "//interfaces/$role" -t elem -n "ipaddr" -v "$ip" \
                -s "//interfaces/$role" -t elem -n "subnet" -v "$prefix" \
                -s "//interfaces/$role" -t elem -n "spoofmac" -v "$ctx_mac" \
                "$file"
        else
            xml ed -L \
                -s "//interfaces" -t elem -n "$role" -v "" \
                -s "//interfaces/$role" -t elem -n "if" -v "$sys_if" \
                -s "//interfaces/$role" -t elem -n "descr" -v "$desc" \
                -s "//interfaces/$role" -t elem -n "enable" -v "" \
                -s "//interfaces/$role" -t elem -n "ipaddr" -v "dhcp" \
                -s "//interfaces/$role" -t elem -n "spoofmac" -v "$ctx_mac" \
                "$file"
        fi

        xml ed -L -d "//dhcpd/$role" "$file" 2>/dev/null
        if is_dhcp_enabled "$ctx_name" && [ -n "$dhcp_start" ] && [ -n "$dhcp_end" ]; then
            ensure_dhcp_node "$file"
            xml ed -L \
                -s "//dhcpd" -t elem -n "$role" -v "" \
                -s "//dhcpd/$role" -t elem -n "range" -v "" \
                -s "//dhcpd/$role/range" -t elem -n "from" -v "$dhcp_start" \
                -s "//dhcpd/$role/range" -t elem -n "to" -v "$dhcp_end" \
                -s "//dhcpd/$role" -t elem -n "enable" -v "" \
                "$file"
            log "$role DHCP enabled: $dhcp_start - $dhcp_end"
        else
            log "$role DHCP disabled"
        fi

        if [ "$role" = "wan" ] && [ "$mode" = "static" ] && [ -n "$gw" ]; then
            route delete default >> "$LOG" 2>&1
            route add default "$gw" >> "$LOG" 2>&1
            xml ed -L -d "//system/gateway" "$file" 2>/dev/null
            xml ed -L -s "//system" -t elem -n "gateway" -v "$gw" "$file"
            xml ed -L -d "//interfaces/$role/gateway" "$file" 2>/dev/null
            xml ed -L -s "//interfaces/$role" -t elem -n "gateway" -v "WANGW" "$file"
            xml ed -L -d "//interfaces/$role/blockpriv" "$file" 2>/dev/null
            xml ed -L -s "//interfaces/$role" -t elem -n "blockpriv" -v "" "$file"
            xml ed -L -d "//interfaces/$role/blockbogons" "$file" 2>/dev/null
            xml ed -L -s "//interfaces/$role" -t elem -n "blockbogons" -v "" "$file"
            log "wan gateway set to $gw"
        fi
    done
}

context_start() {
    log "=== START ContextOnly ==="

    if ! mount_context; then
        log "context media not available"
        return 0
    fi

    if [ ! -f "$CONTEXT_FILE" ]; then
        log "$CONTEXT_FILE not found, exiting"
        umount_context
        return 0
    fi

    # shellcheck source=/dev/null
    . "$CONTEXT_FILE"

    mkdir -p "$BACKUP_DIR"
    cp "$XML_FILE" "$BACKUP_XML"

    configure_network "$BACKUP_XML"

    # DNS configuration
    all_dns=$(set | grep -oE '^ETH(ERNET)?[0-9]+_DNS' | sort -u | while read -r var; do eval "echo \${$var:-}"; done | xargs)
    if [ -n "$all_dns" ]; then
        dns1=$(echo "$all_dns" | awk '{print $1}')
        dns2=$(echo "$all_dns" | awk '{print $NF}')
        : > /etc/resolv.conf
        [ -n "$dns1" ] && echo "nameserver $dns1" >> /etc/resolv.conf
        [ -n "$dns2" ] && echo "nameserver $dns2" >> /etc/resolv.conf
        xml ed -L \
            -u "//system/dnsserver[1]" -v "$dns1" \
            -u "//system/dnsserver[2]" -v "$dns2" \
            -u "//system/dnsallowoverride" -v "" \
            "$BACKUP_XML"
        log "DNS servers set to: $dns1 $dns2"
    fi

    # Hostname
    if [ -n "${SET_HOSTNAME:-}" ]; then
        hostname "$SET_HOSTNAME"
        xml ed -L -u "//system/hostname" -v "$SET_HOSTNAME" "$BACKUP_XML"
        log "hostname set to $SET_HOSTNAME"
    fi

    # SSH public key
    if [ -n "${SSH_PUBLIC_KEY:-}" ]; then
        mkdir -p /root/.ssh
        if [ ! -f /root/.ssh/authorized_keys ] || ! grep -Fxq "$SSH_PUBLIC_KEY" /root/.ssh/authorized_keys; then
            echo "$SSH_PUBLIC_KEY" >> /root/.ssh/authorized_keys
            chmod 600 /root/.ssh/authorized_keys
            chmod 700 /root/.ssh
            log "SSH public key installed"
        fi
    fi

    # Apply config if changed
    if diff -I '<bcrypt-hash>.*</bcrypt-hash>' -q "$XML_FILE" "$BACKUP_XML" >/dev/null; then
        rm -f "$BACKUP_XML"
        log "config.xml unchanged"
    else
        cp "$BACKUP_XML" "$XML_FILE"
        log "config.xml updated"
        /etc/rc.reload_all start >> "$LOG" 2>&1
        pfSsh.php playback restartallwan >> "$LOG" 2>&1
        log "pfSense services reloaded"
    fi

    # PF firewall state
    if [ -n "${PFCTL:-}" ]; then
        case $(echo "$PFCTL" | tr '[:upper:]' '[:lower:]') in
            off|0|false|disabled)
                pfctl -d >> "$LOG" 2>&1
                log "pf firewall disabled"
                ;;
            on|1|true|enabled)
                if pfctl -s info | grep -q 'Status: Disabled'; then
                    pfctl -e >> "$LOG" 2>&1
                    log "pf firewall enabled"
                fi
                ;;
            *)
                log "pf firewall state unchanged (PFCTL=$PFCTL)"
                ;;
        esac
    fi

    # Admin password
    old_hash=$(xml sel -t -m "//user[name='admin']" -v "bcrypt-hash" -n "$XML_FILE")
    if php -r "exit(password_verify('${PASSWORD:-}', '$old_hash') ? 0 : 1);"; then
        log "admin password unchanged"
    else
        pfSsh.php playback ChangePassTool admin "${PASSWORD:-}" >> "$LOG" 2>&1
        log "admin password updated"
    fi

    # Run optional BGP module
    if [ -x /etc/context.d/bgp ]; then
        log "executing /etc/context.d/bgp"
        . /etc/context.d/bgp
        log "bgp module finished with code $?"
    fi

    # SSH key re-check (idempotence)
    if [ -n "${SSH_PUBLIC_KEY:-}" ]; then
        mkdir -p /root/.ssh
        if [ ! -f /root/.ssh/authorized_keys ] || ! grep -Fxq "$SSH_PUBLIC_KEY" /root/.ssh/authorized_keys; then
            echo "$SSH_PUBLIC_KEY" >> /root/.ssh/authorized_keys
            chmod 600 /root/.ssh/authorized_keys
            chmod 700 /root/.ssh
            log "SSH public key installed (second attempt)"
        fi
    fi

    umount_context
    log "=== FINISH ContextOnly ==="
}

run_rc_command "$1"
