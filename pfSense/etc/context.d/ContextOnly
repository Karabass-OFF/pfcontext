#!/bin/sh
# ContextOnly script for pfSense
#set -eu

PATH=/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin:/root/bin
LOG="/var/log/context.log"
#LOG="/dev/null" # Uncomment for disable logging
CONTEXT_MOUNT="/mnt/context"
PID="/etc/context.d/net.pid"
CONTEXT_DEV="/dev/cd0"
CONTEXT_FILE="$CONTEXT_MOUNT/context.sh"
xml_file="/cf/conf/config.xml"
backup_xml_file="/cf/conf/backup/config.xml.$(date +%Y-%m-%d_%H-%M-%S)"
cp "$xml_file"  "$backup_xml_file" # Create a backup of config.xml

: "${WAN_GATEWAY:=}" # desired WAN gateway from context variables
: "${PASSWORD_ROOT:=}" # root password override variable
: "${BGP_ENABLE:=NO}" # BGP is disabled by default
: "${BLOCK_PRIVATE_NETWORKS:=YES}" # default is YES, do not block private networks
: "${BLOCK_BOGON_NETWORKS:=YES}" # default is YES, do not block bogon networks
: "${RC_RELOAD_ALL:=NO}" # default is NO, perform a full services restart
: "${RC_RELOAD_IFACE:=NO}" # по умолчанию NO, рестарт интерфейсов
: "${SSH_PUBLIC_KEY:=}" # public key for root access
: "${MGMT_ENABLE:=NO}" # defined in mgmt.sh
: "${PFCTL:=NO}" # defined in pfctl_off
: "${FIRST_BOOT:=NO}" # defined in firstboot flag file
: "${CONTEXT_IPSEC_ENABLE:=NO}" # defined in context.sh


echo "$(date) [context] === START ContextOnly ===" >> "$LOG"
# default is NO, restart interfaces
mkdir -p "$CONTEXT_MOUNT"
if ! mount | grep -q "on $CONTEXT_MOUNT "; then
    mount -t cd9660 "$CONTEXT_DEV" "$CONTEXT_MOUNT" >> "$LOG" 2>&1
fi

# Mount the CD-ROM if it is not mounted yet
if [ -f "$CONTEXT_FILE" ]; then
    echo "$(date) [context] Found $CONTEXT_FILE — sourcing" >> "$LOG"
     set -a
    # shellcheck source=/dev/null
    . "$CONTEXT_FILE"
    set +a
    get_ctx_var() {
        idx="$1"
        suffix="$2"
        val=""
        eval "val=\${ETH${idx}_${suffix}:-}"
        if [ -z "${val:-}" ]; then
            eval "val=\${ETHERNET${idx}_${suffix}:-}"
        fi
        printf '%s' "${val:-}"
    }
else
    echo "$(date) [context] $CONTEXT_FILE not found, exiting" >> "$LOG"
    exit 0
fi
# Unmount the disk after all operations are complete
if mount | grep -q "on $CONTEXT_MOUNT "; then
    umount "$CONTEXT_MOUNT" && echo "$(date) [context] Unmounted $CONTEXT_MOUNT" >> "$LOG"
else
    echo "$(date) [context] $CONTEXT_MOUNT already unmounted" >> "$LOG"
fi
# --- NETWORKS / INTERFACES ---------------------------------------------------
iface_type_changed=false
added_if_count=0

# Check whether there are any new ETHx_ variables compared to the current config.xml*
ctx_if_count=$(set | grep -oE '^ETH(ERNET)?[0-9]+_MAC' | sort -u | wc -l | awk '{print $1}')
xml_if_count=$(xml sel -t -v "count(//interfaces/*)" "$xml_file" 2>/dev/null || echo 0)
if [ "$ctx_if_count" -gt "$xml_if_count" ]; then
    iface_type_changed=true
    echo "$(date) [context] Detected $ctx_if_count ETHx entries > $xml_if_count XML entries — rebuild required" >> "$LOG"
fi
# Check for description mismatches
for var in $(set | grep -oE '^ETH(ERNET)?[0-9]+_TYPE' | sort -u); do
    idx=$(echo "$var" | grep -oE '[0-9]+')
    ctx_mac=$(get_ctx_var "$idx" "MAC")
    want_type=$(get_ctx_var "$idx" "TYPE")
    [ -n "$ctx_mac" ] || continue
    [ -n "$want_type" ] || continue
 # Look for a system interface with this MAC
    sys_if=$(ifconfig -l | tr ' ' '\n' | while read -r i; do # iterate over all interfaces
        sys_mac=$(ifconfig "$i" | awk '/ether/{print $2}')
        [ "$sys_mac" = "$ctx_mac" ] && echo "$i" && break
    done)
    [ -n "$sys_if" ] || continue
    current_descr=$(ifconfig "$sys_if" | awk -F: '/description/{print $2}' | xargs)
    case "$want_type" in
        lan) want_descr="LAN" ;;
        wan) want_descr="WAN" ;;
        *)   want_descr=$(echo "$want_type" | tr '[:lower:]' '[:upper:]') ;;
    esac
    if [ "$current_descr" != "$want_descr" ]; then
        echo "$(date) [context] ${var} mismatch for $sys_if (MAC=$ctx_mac): want=$want_descr, have=$current_descr" >> "$LOG"
        iface_type_changed=true
    fi
done
# Count the number of explicit LAN/WAN requests to allow auto-assignment
# so auto-assignment won’t override them if the corresponding interface appears later
lan_explicit_count=$(set | grep -oE '^ETH(ERNET)?[0-9]+_TYPE' | sort -u | while read -r var; do
    idx=$(echo "$var" | grep -oE '[0-9]+')
    want=$(get_ctx_var "$idx" "TYPE" | tr '[:upper:]' '[:lower:]')
    [ "${want}" = "lan" ] && echo 1
done | wc -l | awk '{print $1}')
# Number of explicit WAN requests
wan_explicit_count=$(set | grep -oE '^ETH(ERNET)?[0-9]+_TYPE' | sort -u | while read -r var; do
    idx=$(echo "$var" | grep -oE '[0-9]+')
    want=$(get_ctx_var "$idx" "TYPE" | tr '[:upper:]' '[:lower:]')
    [ "${want}" = "wan" ] && echo 1
done | wc -l | awk '{print $1}')
lan_pending=$lan_explicit_count
wan_pending=$wan_explicit_count
# If new interfaces exist or their types have changed, reconfigure them
# all interfaces from scratch (remove everything from config.xml and add them again)
if [ -f "$PID" ] || [ "$iface_type_changed" = "true" ]; then
    xml ed -L -d "//interfaces/*" "$backup_xml_file"
    sys_ifaces=$(ifconfig -l) 
    lan_assigned=false
    wan_assigned=false
    next_opt=1
    used_networks=""
    # Iterate through system interfaces
    for iface in $sys_ifaces; do
        sys_mac=$(ifconfig "$iface" | awk '/ether/ {print $2}')
        [ -n "$sys_mac" ] || continue
        # Look for a matching MAC in context variables
        for var in $(set | grep -oE '^ETH(ERNET)?[0-9]+_MAC' | sort -u); do
            ctx_mac=$(eval "printf '%s' \"\${$var:-}\"")
            [ -n "$ctx_mac" ] || continue
            # Match found — configure it
            if [ "$ctx_mac" = "$sys_mac" ]; then
                idx=$(echo "$var" | grep -oE '[0-9]+')
                ip_addr=$(get_ctx_var "$idx" "IP")
                mask=$(get_ctx_var "$idx" "MASK")
                gw=$(get_ctx_var "$idx" "GATEWAY")
                iface_type=$(get_ctx_var "$idx" "TYPE")
                # Determine the interface type
                if [ -n "$iface_type" ]; then
                    lower_type=$(echo "$iface_type" | tr '[:upper:]' '[:lower:]')
                    case "$lower_type" in
                        lan)
                            # Explicit LAN request
                            if [ "$lan_pending" -gt 0 ]; then
                                lan_pending=$((lan_pending - 1))
                            fi
                            # If LAN is not assigned yet, assign it
                            if [ "$lan_assigned" = "false" ]; then
                                network="lan"
                                desc="LAN"
                                lan_assigned=true
                                used_networks="$used_networks $network"
                            else # If LAN is already assigned, output
                                echo "$(date) [context] Duplicate LAN request for $iface (MAC=$ctx_mac) — assigning OPT" >> "$LOG"
                                candidate="opt$next_opt"
                                # Look for a free OPT interface
                                while echo "$used_networks" | tr ' ' '\n' | grep -qx "$candidate"; do
                                    next_opt=$((next_opt + 1))
                                    candidate="opt$next_opt"
                                done
                                network="$candidate"
                                used_networks="$used_networks $network"
                                next_opt=$((next_opt + 1))
                                desc="$(echo "$network" | tr '[:lower:]' '[:upper:]')"
                            fi
                            ;;
                        wan)
                            # Explicit WAN request
                            if [ "$wan_pending" -gt 0 ]; then
                                wan_pending=$((wan_pending - 1))
                            fi
                            # If WAN is not assigned yet, assign it
                            if [ "$wan_assigned" = "false" ]; then
                                network="wan"
                                desc="WAN"
                                wan_assigned=true
                                used_networks="$used_networks $network"
                            else # If WAN is already assigned, assign OPT instead
                                echo "$(date) [context] Duplicate WAN request for $iface (MAC=$ctx_mac) — assigning OPT" >> "$LOG"
                                candidate="opt$next_opt"
                                # Look for a free OPT
                                while echo "$used_networks" | tr ' ' '\n' | grep -qx "$candidate"; do
                                    next_opt=$((next_opt + 1))
                                    candidate="opt$next_opt"
                                done
                                network="$candidate"
                                used_networks="$used_networks $network"
                                next_opt=$((next_opt + 1))
                                desc="$(echo "$network" | tr '[:lower:]' '[:upper:]')"
                            fi
                            ;;
                        opt[0-9]*)
                            # GET OPTx
                            candidate="$lower_type"
                            if echo "$used_networks" | tr ' ' '\n' | grep -qx "$candidate"; then
                                candidate="opt$next_opt"
                                # Look for a free OPT
                                while echo "$used_networks" | tr ' ' '\n' | grep -qx "$candidate"; do
                                    next_opt=$((next_opt + 1))
                                    candidate="opt$next_opt"
                                done
                                network="$candidate"
                                desc="$(echo "$network" | tr '[:lower:]' '[:upper:]')"
                                used_networks="$used_networks $network"
                                next_opt=$((next_opt + 1))
                            else # OPTx is free, assign it
                                network="$candidate"
                                desc="$(echo "$network" | tr '[:lower:]' '[:upper:]')"
                                used_networks="$used_networks $network"
                                opt_index=$(echo "$candidate" | sed 's/^opt//')
                               # Update next_opt if needed
                                if echo "$opt_index" | grep -Eq '^[0-9]+$'; then
                                    opt_index=$((opt_index + 1))
                                    if [ "$opt_index" -gt "$next_opt" ]; then
                                        next_opt="$opt_index"
                                    fi
                                fi
                            fi
                            ;;
                        *)
                            # Unknown type — assign OPT
                            candidate="opt$next_opt"
                            # Look for a free OPT
                            while echo "$used_networks" | tr ' ' '\n' | grep -qx "$candidate"; do
                                next_opt=$((next_opt + 1))
                                candidate="opt$next_opt"
                            done
                            network="$candidate"
                            used_networks="$used_networks $network"
                            next_opt=$((next_opt + 1))
                            desc="$(echo "$network" | tr '[:lower:]' '[:upper:]')"
                            ;;
                    esac 
                else # Type not specified — assign the next free OPT
                    candidate="opt$next_opt"
                    # Look for a free OPT
                    while echo "$used_networks" | tr ' ' '\n' | grep -qx "$candidate"; do
                        next_opt=$((next_opt + 1))
                        candidate="opt$next_opt"
                    done
                    network="$candidate"
                    used_networks="$used_networks $network"
                    next_opt=$((next_opt + 1))
                    desc="$(echo "$network" | tr '[:lower:]' '[:upper:]')"
                fi
                # Configure the interface
                if [ -n "$ip_addr" ] && [ -n "$mask" ]; then
                    prefix=$(php -r "echo substr_count(decbin(ip2long('$mask')), '1');")
                    ifconfig "$iface" inet "$ip_addr" netmask "$mask" description "$desc"
                    ifconfig "$iface" ether "$ctx_mac"
                    echo "$(date) [context] Added $iface → $desc ($ip_addr/$prefix)" >> "$LOG"
                    added_if_count=$((added_if_count + 1))
                    # Add the interface to config.xml
                    xml ed -L \
                        -s "//interfaces" -t elem -n "$network" -v "" \
                        -s "//interfaces/$network" -t elem -n "descr" -v "$desc" \
                        -s "//interfaces/$network" -t elem -n "enable" -v "YES" \
                        -s "//interfaces/$network" -t elem -n "ipaddr" -v "$ip_addr" \
                        -s "//interfaces/$network" -t elem -n "if" -v "$iface" \
                        -s "//interfaces/$network" -t elem -n "spoofmac" -v "$ctx_mac" \
                        -s "//interfaces/$network" -t elem -n "subnet" -v "$prefix" \
                        "$backup_xml_file"
                    # Protection against issues with the pfSense XML parser (CDATA and empty enable)  
                    sed -i '' \
                        -e "s|<descr>$desc</descr>|<descr><![CDATA[$desc]]></descr>|g" \
                        -e 's|<enable>YES</enable>|<enable></enable>|g' \
                        "$backup_xml_file"
                    if [ "$network" = "wan" ] && [ -n "$gw" ]; then
                      WAN_GATEWAY="$gw"
                    fi
                fi
            fi
        done
    done
    RC_RELOAD_IFACE="YES" # Interface restart is required
fi
echo "$(date) [context] Total interfaces configured: $added_if_count" >> "$LOG"
# --- /Networks ---------------------------------------------------------------
# DNS (collected from all ETHx_DNS values, if provided)
# Combine all DNS servers into a single string
all_dns=$(set | grep -oE '^ETH[0-9]+_DNS' | sort -u | while read -r var; do eval "echo \${$var:-}"; done | xargs)
if [ -n "$all_dns" ]; then # If there is at least one DNS
    # Take the first and the last from the list
    dns1=$(echo "$all_dns" | awk '{print $1}')
    dns2=$(echo "$all_dns" | awk '{print $NF}')
    # Update /etc/resolv.conf
    echo "$(date) [context] Setting DNS: $dns1 $dns2" >> "$LOG"
    : > /etc/resolv.conf
    [ -n "$dns1" ] && echo "nameserver $dns1" >> /etc/resolv.conf
    [ -n "$dns2" ] && echo "nameserver $dns2" >> /etc/resolv.conf
    # Update DNS in config.xml 
    xml ed -L \
        -u "//system/dnsserver[1]" -v "$dns1" \
        -u "//system/dnsserver[2]" -v "$dns2" \
        -u "//system/dnsallowoverride" -v "" \
        "$backup_xml_file"
    echo "$(date) [context] Set DNS: $dns1 $dns2" >> "$LOG"
fi
# Hostname (if variable not empty SET_HOSTNAME)
if [ -n "${SET_HOSTNAME:-}" ]; then
    hostname "$SET_HOSTNAME"
    xml ed -L -u "//system/hostname" -v "$SET_HOSTNAME" "$backup_xml_file"
    echo "$(date) [context] Set hostname: $SET_HOSTNAME" >> "$LOG"
fi
# --- Password override logic ---
if [ -n "${PASSWORD_ROOT}" ]; then
    PASSWORD="${PASSWORD_ROOT}"
    echo "$(date) [context] PASSWORD_ROOT detected → override PASSWORD" >> "$LOG"
fi
# Password admin (playback)
old_hash=$(xml sel -t -m "//user[name='admin']" -v "bcrypt-hash" -n "$backup_xml_file")
if php -r "exit(password_verify('${PASSWORD:-}', '$old_hash') ? 0 : 1);"; then
    echo "$(date) [context] Admin password unchanged" >> "$LOG"
else
     if pfSsh.php playback ChangePassTool admin "${PASSWORD:-}" >> "$LOG" 2>&1; then
        echo "$(date) [context] Admin password changed" >> "$LOG"
        new_hash=$(xml sel -t -m "//user[name='admin']" -v "bcrypt-hash" -n "$xml_file" 2>/dev/null || true)
        if [ -n "$new_hash" ]; then
            xml ed -L -u "//user[name='admin']/bcrypt-hash" -v "$new_hash" "$backup_xml_file"
            echo "$(date) [context] Synced admin bcrypt-hash into backup XML" >> "$LOG"
        else
            echo "$(date) [context] Warning: unable to read new admin bcrypt-hash for backup XML sync" >> "$LOG"
        fi
    else
        echo "$(date) [context] ERROR: failed to change admin password via ChangePassTool" >> "$LOG"
    fi
fi
# obtain the WAN gateway from context variables using the WAN interface’s MAC address
for ifeth in $(ifconfig -l); do
    eth_mac=$(ifconfig "$ifeth" | awk '/ether/ {print $2}')
    [ -n "$eth_mac" ] || continue
    if ifconfig "$ifeth" | grep -q 'description: WAN' ; then
        echo "$(date) [context] Found WAN interface $ifeth (MAC=$eth_mac)" >> "$LOG"
        eth=$(set | grep "ETH" | grep -i "$eth_mac" | cut -d "_" -f 1 )
        #WAN_GATEWAY=$(set | grep "$eth""_GATEWAY=" | cut -d "=" -f 2 | tr -d '"')
        WAN_GATEWAY=$(set | grep -E "^${eth}_GATEWAY=" | head -n1 | cut -d "=" -f 2 | tr -d '"[:space:]')
        echo "$(date) [context] Detected WAN_GATEWAY=$WAN_GATEWAY from $eth" >> "$LOG"
    fi
done
# Check the current default gateway
current_gw=$(netstat -rn | awk '/^0.0.0.0/ {print $2; exit}') 
if [ -n "$WAN_GATEWAY" ]; then
    network="wan"
    sleep 0.2
    if [ "$current_gw" != "$WAN_GATEWAY" ]; then # Change the gateway only if it differs from the current one
        { echo "$(date) [context] Current default gateway: ${current_gw:-"(none)"} differs from desired: $WAN_GATEWAY — updating route (BGP off)" 
          route delete default 
          route add default "$WAN_GATEWAY" 
        } >> "$LOG" 2>&1
        # --- Check whether the <gateways> section exists ---
        if ! xml sel -t -v "//gateways" "$backup_xml_file" >/dev/null 2>&1; then
            echo "$(date) [context] Gateways section missing — creating one" >> "$LOG"
            xml ed -L -s "//pfsense" -t elem -n "gateways" -v "" "$backup_xml_file"
        fi
        # Remove any existing old gateway before adding the new one
        xml ed -L -d "//gateways/gateway_item[name='WANGW']" "$backup_xml_file"
        xml ed -L -d "//interfaces//gateway[text()='WANGW']" "$backup_xml_file"
        xml ed -L -d "//gateways/defaultgw4[text()='WANGW']" "$backup_xml_file"
        # Add the gateway to config.xml
        xml ed -L \
            -s "//gateways" -t elem -n "gateway_item" -v "" \
            -s "//gateways/gateway_item[last()]" -t elem -n "interface" -v "$network" \
            -s "//gateways/gateway_item[last()]" -t elem -n "gateway" -v "$WAN_GATEWAY" \
            -s "//gateways/gateway_item[last()]" -t elem -n "name" -v "WANGW" \
            -s "//gateways/gateway_item[last()]" -t elem -n "descr" -v "Default IPv4 Gateway" \
            -s "//gateways/gateway_item[last()]" -t elem -n "defaultgw4" -v "yes" \
            -s "//gateways/gateway_item[last()]" -t elem -n "weight" -v "1" \
            -u "//gateways/defaultgw4" -v "WANGW" \
            "$backup_xml_file"
            # Bind the WANGW gateway to the WAN interface if it is not already set
            xml ed -L -s "//interfaces/$network" -t elem -n "gateway" -v "WANGW" "$backup_xml_file"
            echo "$(date) [context] Added gateway WANGW to $network" >> "$LOG"
    elif [ "$current_gw" = "$WAN_GATEWAY" ]; then # Шлюз уже установлен и совпадает с нужным 
        echo "$(date) [context] Current default gateway: $current_gw matches desired: $WAN_GATEWAY — no change needed" >> "$LOG"
    fi
fi

# --- ADDITIONAL MODULES — DO NOT CHANGE THE EXECUTION ORDER ---
# 1. Disable/Enable the pfSense firewall (pfctl)
# shellcheck disable=SC1091
. /etc/context.d/modules/pfctl.sh
# 2. Sync config.xml (if there are changes)
# shellcheck disable=SC1091
. /etc/context.d/modules/sync-conf.sh
  export RC_RELOAD_IFACE
# 3. Reload interfaces (if required)
# shellcheck disable=SC1091
. /etc/context.d/modules/reload-iface.sh
# 4. SSH module for adding an SSH key
# shellcheck disable=SC1091
[ -n "${SSH_PUBLIC_KEY:-}" ] && . /etc/context.d/modules/addsshkey.sh

# FIRST RUN — EXECUTE ON FIRST START OR WHEN FIRST_BOOT=NO
FIRSTBOOT_FLAG="/etc/context.d/firstboot"
if [ ! -f "$FIRSTBOOT_FLAG" ] || [ "${FIRST_BOOT}" = "YES" ]; then
    #touch /etc/context.d/firstboot
    # create firstboot flag file for cron job 2 minutes later boot system /etc/cron.d/context

    # BGP module
    # shellcheck disable=SC1091
    . /etc/context.d/modules/bgp

    # Management interface module
    # shellcheck disable=SC1091
    [ "${MGMT_ENABLE}" = "YES" ] && . /etc/context.d/modules/mgmt.sh 
    
    # IPsec configuration module
    # shellcheck disable=SC1091
    [ "${CONTEXT_IPSEC_ENABLE}" = "YES" ] && . /etc/context.d/modules/ipsec.sh 

    # NAT configuration module
    # shellcheck disable=SC1091
    [ "${NAT_ENABLE}" = "YES" ] && . /etc/context.d/modules/nat.sh

    echo "$(date) [context] First boot operations completed, created /etc/context.d/firstboot" >> "$LOG"
else
    echo "$(date) [context] Not first boot, skipping runing modules: bgp, mgmt, ipsec" >> "$LOG"
fi

# Remove the PID file after successful completion of operations 
if [ -f "$PID" ]; then
    {
        echo "$(date) [context] Файл найден: $PID = cat $PID" 
        rm -f "$PID" && echo "Файл $PID удалён."
    } >> "$LOG"
fi
echo "$(date) [context] FINISH" >> "$LOG"