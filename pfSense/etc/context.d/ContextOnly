#!/bin/sh
#
# ContextOnly script for pfSense
#
PATH=/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin:/root/bin
LOG="/var/log/context.log"
#LOG="/dev/null" # Uncomment for disable logging
CONTEXT_MOUNT="/mnt/context"
PID="/etc/context.d/net.pid"
CONTEXT_DEV="/dev/cd0"
CONTEXT_FILE="$CONTEXT_MOUNT/context.sh"
xml_file="/cf/conf/config.xml"
backup_xml_file="/cf/conf/backup/config.xml.$(date +%Y.%m.%d.%H:%M:%S)"

echo "$(date) [context] === START ContextOnly $(date) ===" >> "$LOG"
# Монтируем CD-ROM, если он еще не смонтирован
mkdir -p "$CONTEXT_MOUNT"
if ! mount | grep -q "on $CONTEXT_MOUNT "; then
    mount -t cd9660 "$CONTEXT_DEV" "$CONTEXT_MOUNT" >> "$LOG" 2>&1
fi
# Проверяем наличие файла context.sh на CD-ROM
if [ -f "$CONTEXT_FILE" ]; then
    echo "$(date) [context] Found $CONTEXT_FILE — sourcing" >> "$LOG"
    # shellcheck source=/dev/null
    . "$CONTEXT_FILE"
    cp "$xml_file" "$backup_xml_file" # Создаем резервную копию config.xml
    get_ctx_var() {
        idx="$1"
        suffix="$2"
        val=""
        eval "val=\${ETH${idx}_${suffix}:-}"
        if [ -z "${val:-}" ]; then
            eval "val=\${ETHERNET${idx}_${suffix}:-}"
        fi
        printf '%s' "${val:-}"
    }
else
    echo "$(date) [context] $CONTEXT_FILE not found, exiting" >> "$LOG"
    exit 0
fi
# --- СЕТИ / ИНТЕРФЕЙСЫ ---------------------------------------------------
iface_type_changed=false
added_if_count=0
# Проверяем, есть ли новые ETHx_* переменные против текущего config.xml
ctx_if_count=$(set | grep -oE '^ETH(ERNET)?[0-9]+_MAC' | sort -u | wc -l | awk '{print $1}')
xml_if_count=$(xml sel -t -v "count(//interfaces/*)" "$xml_file" 2>/dev/null || echo 0)
if [ "$ctx_if_count" -gt "$xml_if_count" ]; then
    iface_type_changed=true
    echo "$(date) [context] Detected $ctx_if_count ETHx entries > $xml_if_count XML entries — rebuild required" >> "$LOG"
fi
# Проверяем несоответствия по описанию
for var in $(set | grep -oE '^ETH(ERNET)?[0-9]+_TYPE' | sort -u); do
    idx=$(echo "$var" | grep -oE '[0-9]+')
    ctx_mac=$(get_ctx_var "$idx" "MAC")
    want_type=$(get_ctx_var "$idx" "TYPE")
    [ -n "$ctx_mac" ] || continue
    [ -n "$want_type" ] || continue
    # Ищем системный интерфейс с таким MAC
    sys_if=$(ifconfig -l | tr ' ' '\n' | while read -r i; do # перебираем все интерфейсы
        sys_mac=$(ifconfig "$i" | awk '/ether/{print $2}')
        [ "$sys_mac" = "$ctx_mac" ] && echo "$i" && break
    done)
    [ -n "$sys_if" ] || continue
    current_descr=$(ifconfig "$sys_if" | awk -F: '/description/{print $2}' | xargs)
    case "$want_type" in
        lan) want_descr="LAN" ;;
        wan) want_descr="WAN" ;;
        *)   want_descr=$(echo "$want_type" | tr '[:lower:]' '[:upper:]') ;;
    esac
    if [ "$current_descr" != "$want_descr" ]; then
        echo "$(date) [context] ${var} mismatch for $sys_if (MAC=$ctx_mac): want=$want_descr, have=$current_descr" >> "$LOG"
        iface_type_changed=true
    fi
done
# Подсчитываем количество явных запросов LAN/WAN, чтобы авто-назначение
# не перехватывало их, если соответствующий интерфейс встретится позже
lan_explicit_count=$(set | grep -oE '^ETH(ERNET)?[0-9]+_TYPE' | sort -u | while read -r var; do
    idx=$(echo "$var" | grep -oE '[0-9]+')
    want=$(get_ctx_var "$idx" "TYPE" | tr '[:upper:]' '[:lower:]')
    [ "${want}" = "lan" ] && echo 1
done | wc -l | awk '{print $1}')
# Количество явных запросов WAN
wan_explicit_count=$(set | grep -oE '^ETH(ERNET)?[0-9]+_TYPE' | sort -u | while read -r var; do
    idx=$(echo "$var" | grep -oE '[0-9]+')
    want=$(get_ctx_var "$idx" "TYPE" | tr '[:upper:]' '[:lower:]')
    [ "${want}" = "wan" ] && echo 1
done | wc -l | awk '{print $1}')
lan_pending=$lan_explicit_count
wan_pending=$wan_explicit_count
# Если есть новые интерфейсы или изменились типы, перенастраиваем
# все интерфейсы заново (удаляем все из config.xml и добавляем по новой)
if [ -f "$PID" ] || [ "$iface_type_changed" = "true" ]; then
    xml ed -L -d "//interfaces/*" "$backup_xml_file"
    sys_ifaces=$(ifconfig -l) 
    lan_assigned=false
    wan_assigned=false
    next_opt=1
    used_networks=""
    # Перебираем системные интерфейсы
    for iface in $sys_ifaces; do
        sys_mac=$(ifconfig "$iface" | awk '/ether/ {print $2}')
        [ -n "$sys_mac" ] || continue
        # Ищем соответствие MAC в контекстных переменных
        for var in $(set | grep -oE '^ETH(ERNET)?[0-9]+_MAC' | sort -u); do
            ctx_mac=$(eval "printf '%s' \"\${$var:-}\"")
            [ -n "$ctx_mac" ] || continue
            # Совпало — настраиваем
            if [ "$ctx_mac" = "$sys_mac" ]; then
                idx=$(echo "$var" | grep -oE '[0-9]+')
                ip_addr=$(get_ctx_var "$idx" "IP")
                mask=$(get_ctx_var "$idx" "MASK")
                gw=$(get_ctx_var "$idx" "GATEWAY")
                iface_type=$(get_ctx_var "$idx" "TYPE")
                # Определяем тип интерфейса
                if [ -n "$iface_type" ]; then
                    lower_type=$(echo "$iface_type" | tr '[:upper:]' '[:lower:]')
                    case "$lower_type" in
                        lan)
                            # Явный запрос LAN
                            if [ "$lan_pending" -gt 0 ]; then
                                lan_pending=$((lan_pending - 1))
                            fi
                            # Если LAN еще не назначен, назначаем
                            if [ "$lan_assigned" = "false" ]; then
                                network="lan"
                                desc="LAN"
                                lan_assigned=true
                                used_networks="$used_networks $network"
                            else # Если LAN уже назначен, выдаем OPT
                                echo "$(date) [context] Duplicate LAN request for $iface (MAC=$ctx_mac) — assigning OPT" >> "$LOG"
                                candidate="opt$next_opt"
                                # Ищем свободный OPT
                                while echo "$used_networks" | tr ' ' '\n' | grep -qx "$candidate"; do
                                    next_opt=$((next_opt + 1))
                                    candidate="opt$next_opt"
                                done
                                network="$candidate"
                                used_networks="$used_networks $network"
                                next_opt=$((next_opt + 1))
                                desc="$(echo "$network" | tr '[:lower:]' '[:upper:]')"
                            fi
                            ;;
                        wan)
                            # Явный запрос WAN
                            if [ "$wan_pending" -gt 0 ]; then
                                wan_pending=$((wan_pending - 1))
                            fi
                            # Если WAN еще не назначен, назначаем
                            if [ "$wan_assigned" = "false" ]; then
                                network="wan"
                                desc="WAN"
                                wan_assigned=true
                                used_networks="$used_networks $network"
                            else # Если WAN уже назначен, выдаем OPT
                                echo "$(date) [context] Duplicate WAN request for $iface (MAC=$ctx_mac) — assigning OPT" >> "$LOG"
                                candidate="opt$next_opt"
                                # Ищем свободный OPT
                                while echo "$used_networks" | tr ' ' '\n' | grep -qx "$candidate"; do
                                    next_opt=$((next_opt + 1))
                                    candidate="opt$next_opt"
                                done
                                network="$candidate"
                                used_networks="$used_networks $network"
                                next_opt=$((next_opt + 1))
                                desc="$(echo "$network" | tr '[:lower:]' '[:upper:]')"
                            fi
                            ;;
                        opt[0-9]*)
                            # Запрос OPTx
                            candidate="$lower_type"
                            if echo "$used_networks" | tr ' ' '\n' | grep -qx "$candidate"; then
                                candidate="opt$next_opt"
                                # Ищем свободный OPT
                                while echo "$used_networks" | tr ' ' '\n' | grep -qx "$candidate"; do
                                    next_opt=$((next_opt + 1))
                                    candidate="opt$next_opt"
                                done
                                network="$candidate"
                                desc="$(echo "$network" | tr '[:lower:]' '[:upper:]')"
                                used_networks="$used_networks $network"
                                next_opt=$((next_opt + 1))
                            else # OPTx свободен, назначаем его
                                network="$candidate"
                                desc="$(echo "$network" | tr '[:lower:]' '[:upper:]')"
                                used_networks="$used_networks $network"
                                opt_index=$(echo "$candidate" | sed 's/^opt//')
                                # Обновляем next_opt, если нужно
                                if echo "$opt_index" | grep -Eq '^[0-9]+$'; then
                                    opt_index=$((opt_index + 1))
                                    if [ "$opt_index" -gt "$next_opt" ]; then
                                        next_opt="$opt_index"
                                    fi
                                fi
                            fi
                            ;;
                        *)
                            # Неизвестный тип — выдаем OPT
                            candidate="opt$next_opt"
                            # Ищем свободный OPT
                            while echo "$used_networks" | tr ' ' '\n' | grep -qx "$candidate"; do
                                next_opt=$((next_opt + 1))
                                candidate="opt$next_opt"
                            done
                            network="$candidate"
                            used_networks="$used_networks $network"
                            next_opt=$((next_opt + 1))
                            desc="$(echo "$network" | tr '[:lower:]' '[:upper:]')"
                            ;;
                    esac 
                else # Тип не указан — авто-назначение
                    # Если IP из приватного диапазона, пытаемся назначить LAN
                    if echo "$ip_addr" | grep -Eq '^10\.|^172\.(1[6-9]|2[0-9]|3[0-1])\.|^192\.168\.' ; then
                        # Приватный IP
                        if [ "$lan_assigned" = "false" ] && [ "$lan_pending" -eq 0 ]; then
                            network="lan"
                            desc="LAN"
                            lan_assigned=true
                            used_networks="$used_networks $network"
                        else # LAN уже назначен или ожидается — выдаем OPT
                            candidate="opt$next_opt"
                            # Ищем свободный OPT
                            while echo "$used_networks" | tr ' ' '\n' | grep -qx "$candidate"; do
                                next_opt=$((next_opt + 1))
                                candidate="opt$next_opt"
                            done
                            network="$candidate"
                            used_networks="$used_networks $network"
                            next_opt=$((next_opt + 1))
                            desc="$(echo "$network" | tr '[:lower:]' '[:upper:]')"
                        fi
                    else 
                        # Публичный IP — пытаемся назначить WAN
                        if [ "$wan_assigned" = "false" ] && [ "$wan_pending" -eq 0 ]; then
                            network="wan"
                            desc="WAN"
                            wan_assigned=true
                            used_networks="$used_networks $network"
                        else # WAN уже назначен или ожидается — выдаем OPT
                            candidate="opt$next_opt"
                            # Ищем свободный OPT
                            while echo "$used_networks" | tr ' ' '\n' | grep -qx "$candidate"; do
                                next_opt=$((next_opt + 1))
                                candidate="opt$next_opt"
                            done
                            network="$candidate"
                            used_networks="$used_networks $network"
                            next_opt=$((next_opt + 1))
                            desc="$(echo "$network" | tr '[:lower:]' '[:upper:]')"
                        fi
                    fi
                fi
                # Конфигурируем интерфейс
                if [ -n "$ip_addr" ] && [ -n "$mask" ]; then
                    prefix=$(php -r "echo substr_count(decbin(ip2long('$mask')), '1');")
                    ifconfig "$iface" inet "$ip_addr" netmask "$mask" description "$desc"
                    ifconfig "$iface" ether "$ctx_mac"
                    echo "$(date) [context] Added $iface → $desc ($ip_addr/$prefix)" >> "$LOG"
                    added_if_count=$((added_if_count + 1))
                    # Добавляем интерфейс в config.xml
                    xml ed -L \
                        -s "//interfaces" -t elem -n "$network" -v "" \
                        -s "//interfaces/$network" -t elem -n "descr" -v "$desc" \
                        -s "//interfaces/$network" -t elem -n "enable" -v "YES" \
                        -s "//interfaces/$network" -t elem -n "ipaddr" -v "$ip_addr" \
                        -s "//interfaces/$network" -t elem -n "if" -v "$iface" \
                        -s "//interfaces/$network" -t elem -n "spoofmac" -v "$ctx_mac" \
                        -s "//interfaces/$network" -t elem -n "subnet" -v "$prefix" \
                        "$backup_xml_file"
                    # Защита от проблем с XML-парсером pfSense (CDATA и пустой enable)  
                    sed -i '' \
                        -e "s|<descr>$desc</descr>|<descr><![CDATA[$desc]]></descr>|g" \
                        -e 's|<enable>YES</enable>|<enable></enable>|g' \
                        "$backup_xml_file"
                    # Настраиваем шлюз по умолчанию для WAN
                    if [ "$network" = "wan" ] && [ -n "$gw" ]; then
                        route delete default >/dev/null 2>&1
                        route add default "$gw"
                        # Отключаем/Включаем private networks для WAN
                        if [ -n "$BLOCK_PRIVATE_NETWORKS" ] && [ "$BLOCK_PRIVATE_NETWORKS" = "on" ]; then
                            xml ed -L \
                                -s "//interfaces/$network" -t elem -n "blockbogons" -v "" \
                                "$backup_xml_file"
                            echo "$(date) [context] BLOCK_PRIVATE_NETWORKS" >> "$LOG"
                        else
                            xml ed -L \
                                -d "//interfaces/$network/blockbogons" \
                                "$backup_xml_file"
                            echo "$(date) [context] No BLOCK_PRIVATE_NETWORKS" >> "$LOG"
                        fi
                        # Отключаем/Включаем bogon networks для WAN
                        if [ -n "$BLOCK_BOGON_NETWORKS" ] && [ "$BLOCK_BOGON_NETWORKS" = "on" ]; then
                            xml ed -L \
                                -s "//interfaces/$network" -t elem -n "blockpriv" -v "" \
                                "$backup_xml_file"
                            echo "$(date) [context] BLOCK_BOGON_NETWORKS" >> "$LOG"
                        else
                            xml ed -L \
                                -d "//interfaces/$network/blockpriv" \
                                "$backup_xml_file"
                            echo "$(date) [context] No BLOCK_BOGON_NETWORKS" >> "$LOG"
                        fi
                        
                        # Добавляем шлюз в config.xml
                        xml ed -L \
                            -d "//system/gateway" \
                            -s "//system" -t elem -n "gateway" -v "$gw" \
                            -s "//interfaces/$network" -t elem -n "gateway" -v "WANGW" \
                            "$backup_xml_file"
                        echo "$(date) [context] Gateway: $gw" >> "$LOG"
                    fi
                fi
            fi
        done
    done
fi
echo "$(date) [context] Total interfaces configured: $added_if_count" >> "$LOG"
# --- /СЕТИ ---------------------------------------------------------------
# DNS (берем из всех ETHx_DNS, если указаны)
# Собираем все DNS в одну строку
all_dns=$(set | grep -oE '^ETH[0-9]+_DNS' | sort -u | while read -r var; do eval "echo \${$var:-}"; done | xargs)
if [ -n "$all_dns" ]; then # Если есть хотя бы один DNS
    # Берем первый и последний из списка
    dns1=$(echo "$all_dns" | awk '{print $1}')
    dns2=$(echo "$all_dns" | awk '{print $NF}')
    # Обновляем /etc/resolv.conf
    echo "$(date) [context] Setting DNS: $dns1 $dns2" >> "$LOG"
    : > /etc/resolv.conf
    [ -n "$dns1" ] && echo "nameserver $dns1" >> /etc/resolv.conf
    [ -n "$dns2" ] && echo "nameserver $dns2" >> /etc/resolv.conf
    # Обновляем DNS в config.xml (если указаны)
    xml ed -L \
        -u "//system/dnsserver[1]" -v "$dns1" \
        -u "//system/dnsserver[2]" -v "$dns2" \
        -u "//system/dnsallowoverride" -v "" \
        "$backup_xml_file"
    echo "$(date) [context] Set DNS: $dns1 $dns2" >> "$LOG"
fi
# Hostname (если указана переменная SET_HOSTNAME)
if [ -n "${SET_HOSTNAME:-}" ]; then
    hostname "$SET_HOSTNAME"
    xml ed -L -u "//system/hostname" -v "$SET_HOSTNAME" "$backup_xml_file"
    echo "$(date) [context] Set hostname: $SET_HOSTNAME" >> "$LOG"
fi


# Пароль admin (через playback)
old_hash=$(xml sel -t -m "//user[name='admin']" -v "bcrypt-hash" -n "$backup_xml_file")
if php -r "exit(password_verify('${PASSWORD:-}', '$old_hash') ? 0 : 1);"; then
    echo "$(date) [context] Admin password unchanged" >> "$LOG"
else
    pfSsh.php playback ChangePassTool admin "${PASSWORD:-}" >> "$LOG" 2>&1
    echo "$(date) [context] Admin password changed" >> "$LOG"
fi
# Синхронизация config.xml (если есть изменения)
if diff -I '<bcrypt-hash>.*</bcrypt-hash>' -q "$xml_file" "$backup_xml_file" >/dev/null; then
    rm -f "$backup_xml_file"
    echo "$(date) [context] No changes in config.xml, backup_xml_file removed" >> "$LOG"
elif [ -s "$backup_xml_file" ]; then # Если файл не пустой, копируем его в config.xml
    cp "$backup_xml_file" "$xml_file"
    echo "$(date) [context] config.xml updated, backup_xml_file saved to $backup_xml_file" >> "$LOG"
    # Перезагрузка служб pfSense (если указано в контексте)
    
    if [ "${RC_RELOAD_ALL}" = "on" ]; then
        # Перезагружаем службы pfSense
        /etc/rc.reload_all start >> "$LOG" 2>&1
        echo "$(date) [context] pfSense services reloaded" >> "$LOG"
        pfSsh.php playback restartallwan >> "$LOG" 2>&1
        echo "$(date) [context] pfSense services restarted" >> "$LOG"
    fi
    # Перезагрузка интерфейсов pfSense (если указано в контексте)
    if [ "${RC_RELOAD_IFACE}" = "on" ]; then
        # Перезагружаем интерфейсы pfSense
        pfSsh.php playback restartallwan >> "$LOG" 2>&1
        echo "$(date) [context] pfSense services restarted" >> "$LOG"
    fi
fi
# отключение/включение pfSense firewall (pfctl) 
if [ -n "${PFCTL:-}" ]; then # если переменная PFCTL указана
    # Приводим значение к нижнему регистру для удобства сравнения   
    _lc_pfctl=$(echo "${PFCTL}" | tr '[:upper:]' '[:lower:]')
    case "$_lc_pfctl" in
        yes|off|0|false|disabled)
            pfctl -d >> "$LOG" 2>&1
            echo "$(date) [context] pfSense firewall disabled" >> "$LOG"
            ;;
        no|on|1|true|enabled)
            if pfctl -s info | grep -q 'Status: Disabled'; then
                echo "$(date) [context] pfSense firewall was disabled, enabling now" >> "$LOG"
                pfctl -e >> "$LOG" 2>&1
                echo "$(date) [context] pfSense firewall enabled" >> "$LOG"
            fi
            ;;
        *)
            echo "$(date) [context] pfSense firewall state unchanged (PFCTL=$_lc_pfctl)" >> "$LOG"
            ;;
    esac
fi
# Отмонтировать диск после выполнения всех операций
if mount | grep -q "on $CONTEXT_MOUNT "; then
    umount "$CONTEXT_MOUNT" && echo "$(date) [context] Unmounted $CONTEXT_MOUNT" >> "$LOG"
else
    echo "$(date) [context] $CONTEXT_MOUNT already unmounted" >> "$LOG"
fi
# --- ДОПОЛНИТЕЛЬНЫЕ МОДУЛИ ------------------------------------------------
# BGP-модуль 
if [ -x /etc/context.d/bgp ]; then
    echo "$(date) [context] Running BGP module /etc/context.d/bgp" >> "$LOG"
    . /etc/context.d/bgp
    echo "$(date) [context] BGP module (return $?)" >> "$LOG"
fi


# SSH ключ (если указана переменная SSH_PUBLIC_KEY)
if [ -n "${SSH_PUBLIC_KEY:-}" ]; then
    mkdir -p /root/.ssh
    if [ ! -f /root/.ssh/authorized_keys ] || ! grep -Fxq "$SSH_PUBLIC_KEY" /root/.ssh/authorized_keys; then
        # кодируем ключ в base64 (без переносов строк)
        ENC_KEY=$(printf '%s' "$SSH_PUBLIC_KEY" | base64 | tr -d '\n')
        if xml sel -t -v "//user[name='admin']/authorizedkeys" "$xml_file" >/dev/null 2>&1; then
            xml ed -L -u "//user[name='admin']/authorizedkeys" -v "$ENC_KEY" "$xml_file"
        else
            xml ed -L -s "//user[name='admin']" -t elem -n "authorizedkeys" -v "$ENC_KEY" "$xml_file"
        fi
        echo "$(date) [context] SSH public key updated in config.xml" >> "$LOG"
        echo "$SSH_PUBLIC_KEY" >> /root/.ssh/authorized_keys
        chmod 600 /root/.ssh/authorized_keys
        chmod 700 /root/.ssh
        echo "$(date) [context] SSH public key updated" >> "$LOG"
        #RC_RELOAD_ALL="on" && echo "$(date) [context] RC_RELOAD_ALL set to on due to SSH key change" >> "$LOG"
    fi
fi

echo "$(date) [context] FINISH" >> "$LOG"
