#!/bin/sh
# ContextOnly script for pfSense
#set -eu

PATH=/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin:/root/bin
LOG="/var/log/context.log"
#LOG="/dev/null" # Uncomment for disable logging
CONTEXT_MOUNT="/mnt/context"
PID="/etc/context.d/net.pid"
CONTEXT_DEV="/dev/cd0"
CONTEXT_FILE="$CONTEXT_MOUNT/context.sh"
xml_file="/cf/conf/config.xml"
backup_xml_file="/cf/conf/backup/config.xml.$(date +%Y.%m.%d.%H:%M:%S)"
SCRIPT_VERSION="$(cat /etc/context.d/VERSION 2>/dev/null || echo "unknown")"

: "${WAN_GATEWAY:=}" # desired WAN gateway from context variables
: "${PASSWORD_ROOT:=}" # root password override variable
: "${BGP_ENABLE:=NO}" # по умолчанию BGP выключен
: "${BLOCK_PRIVATE_NETWORKS:=off}" # по умолчанию off, не блокировать private-сети
: "${BLOCK_BOGON_NETWORKS:=off}" # по умолчанию off, не блокировать bogon-сети
: "${RC_RELOAD_ALL:=off}" # по умолчанию off, полный рестарт служб
: "${RC_RELOAD_IFACE:=off}" # по умолчанию off, рестарт интерфейсов
: "${SSH_PUBLIC_KEY:=}" # public key for root access
: "${MGMT_ENABLE:=}" # defined in mgmt.sh
: "${PFCTL:=}" # defined in pfctl_off

echo "$(date) [context] === START ContextOnly $SCRIPT_VERSION ===" >> "$LOG"
# Монтируем CD-ROM, если он еще не смонтирован
mkdir -p "$CONTEXT_MOUNT"
if ! mount | grep -q "on $CONTEXT_MOUNT "; then
    mount -t cd9660 "$CONTEXT_DEV" "$CONTEXT_MOUNT" >> "$LOG" 2>&1
fi
# Проверяем наличие файла context.sh на CD-ROM
if [ -f "$CONTEXT_FILE" ]; then
    echo "$(date) [context] Found $CONTEXT_FILE — sourcing" >> "$LOG"
    # shellcheck source=/dev/null
    . "$CONTEXT_FILE"
    cp "$xml_file" "$backup_xml_file" # Создаем резервную копию config.xml
    get_ctx_var() {
        idx="$1"
        suffix="$2"
        val=""
        eval "val=\${ETH${idx}_${suffix}:-}"
        if [ -z "${val:-}" ]; then
            eval "val=\${ETHERNET${idx}_${suffix}:-}"
        fi
        printf '%s' "${val:-}"
    }
else
    echo "$(date) [context] $CONTEXT_FILE not found, exiting" >> "$LOG"
    exit 0
fi
# --- СЕТИ / ИНТЕРФЕЙСЫ ---------------------------------------------------
iface_type_changed=false
added_if_count=0
# Проверяем, есть ли новые ETHx_* переменные против текущего config.xml
ctx_if_count=$(set | grep -oE '^ETH(ERNET)?[0-9]+_MAC' | sort -u | wc -l | awk '{print $1}')
xml_if_count=$(xml sel -t -v "count(//interfaces/*)" "$xml_file" 2>/dev/null || echo 0)
if [ "$ctx_if_count" -gt "$xml_if_count" ]; then
    iface_type_changed=true
    echo "$(date) [context] Detected $ctx_if_count ETHx entries > $xml_if_count XML entries — rebuild required" >> "$LOG"
fi
# Проверяем несоответствия по описанию
for var in $(set | grep -oE '^ETH(ERNET)?[0-9]+_TYPE' | sort -u); do
    idx=$(echo "$var" | grep -oE '[0-9]+')
    ctx_mac=$(get_ctx_var "$idx" "MAC")
    want_type=$(get_ctx_var "$idx" "TYPE")
    [ -n "$ctx_mac" ] || continue
    [ -n "$want_type" ] || continue
    # Ищем системный интерфейс с таким MAC
    sys_if=$(ifconfig -l | tr ' ' '\n' | while read -r i; do # перебираем все интерфейсы
        sys_mac=$(ifconfig "$i" | awk '/ether/{print $2}')
        [ "$sys_mac" = "$ctx_mac" ] && echo "$i" && break
    done)
    [ -n "$sys_if" ] || continue
    current_descr=$(ifconfig "$sys_if" | awk -F: '/description/{print $2}' | xargs)
    case "$want_type" in
        lan) want_descr="LAN" ;;
        wan) want_descr="WAN" ;;
        *)   want_descr=$(echo "$want_type" | tr '[:lower:]' '[:upper:]') ;;
    esac
    if [ "$current_descr" != "$want_descr" ]; then
        echo "$(date) [context] ${var} mismatch for $sys_if (MAC=$ctx_mac): want=$want_descr, have=$current_descr" >> "$LOG"
        iface_type_changed=true
    fi
done
# Подсчитываем количество явных запросов LAN/WAN, чтобы авто-назначение
# не перехватывало их, если соответствующий интерфейс встретится позже
lan_explicit_count=$(set | grep -oE '^ETH(ERNET)?[0-9]+_TYPE' | sort -u | while read -r var; do
    idx=$(echo "$var" | grep -oE '[0-9]+')
    want=$(get_ctx_var "$idx" "TYPE" | tr '[:upper:]' '[:lower:]')
    [ "${want}" = "lan" ] && echo 1
done | wc -l | awk '{print $1}')
# Количество явных запросов WAN
wan_explicit_count=$(set | grep -oE '^ETH(ERNET)?[0-9]+_TYPE' | sort -u | while read -r var; do
    idx=$(echo "$var" | grep -oE '[0-9]+')
    want=$(get_ctx_var "$idx" "TYPE" | tr '[:upper:]' '[:lower:]')
    [ "${want}" = "wan" ] && echo 1
done | wc -l | awk '{print $1}')
lan_pending=$lan_explicit_count
wan_pending=$wan_explicit_count
# Если есть новые интерфейсы или изменились типы, перенастраиваем
# все интерфейсы заново (удаляем все из config.xml и добавляем по новой)
if [ -f "$PID" ] || [ "$iface_type_changed" = "true" ]; then
    xml ed -L -d "//interfaces/*" "$backup_xml_file"
    sys_ifaces=$(ifconfig -l) 
    lan_assigned=false
    wan_assigned=false
    next_opt=1
    used_networks=""
    # Перебираем системные интерфейсы
    for iface in $sys_ifaces; do
        sys_mac=$(ifconfig "$iface" | awk '/ether/ {print $2}')
        [ -n "$sys_mac" ] || continue
        # Ищем соответствие MAC в контекстных переменных
        for var in $(set | grep -oE '^ETH(ERNET)?[0-9]+_MAC' | sort -u); do
            ctx_mac=$(eval "printf '%s' \"\${$var:-}\"")
            [ -n "$ctx_mac" ] || continue
            # Совпало — настраиваем
            if [ "$ctx_mac" = "$sys_mac" ]; then
                idx=$(echo "$var" | grep -oE '[0-9]+')
                ip_addr=$(get_ctx_var "$idx" "IP")
                mask=$(get_ctx_var "$idx" "MASK")
                gw=$(get_ctx_var "$idx" "GATEWAY")
                iface_type=$(get_ctx_var "$idx" "TYPE")
                # Определяем тип интерфейса
                if [ -n "$iface_type" ]; then
                    lower_type=$(echo "$iface_type" | tr '[:upper:]' '[:lower:]')
                    case "$lower_type" in
                        lan)
                            # Явный запрос LAN
                            if [ "$lan_pending" -gt 0 ]; then
                                lan_pending=$((lan_pending - 1))
                            fi
                            # Если LAN еще не назначен, назначаем
                            if [ "$lan_assigned" = "false" ]; then
                                network="lan"
                                desc="LAN"
                                lan_assigned=true
                                used_networks="$used_networks $network"
                            else # Если LAN уже назначен, выдаем OPT
                                echo "$(date) [context] Duplicate LAN request for $iface (MAC=$ctx_mac) — assigning OPT" >> "$LOG"
                                candidate="opt$next_opt"
                                # Ищем свободный OPT
                                while echo "$used_networks" | tr ' ' '\n' | grep -qx "$candidate"; do
                                    next_opt=$((next_opt + 1))
                                    candidate="opt$next_opt"
                                done
                                network="$candidate"
                                used_networks="$used_networks $network"
                                next_opt=$((next_opt + 1))
                                desc="$(echo "$network" | tr '[:lower:]' '[:upper:]')"
                            fi
                            ;;
                        wan)
                            # Явный запрос WAN
                            if [ "$wan_pending" -gt 0 ]; then
                                wan_pending=$((wan_pending - 1))
                            fi
                            # Если WAN еще не назначен, назначаем
                            if [ "$wan_assigned" = "false" ]; then
                                network="wan"
                                desc="WAN"
                                wan_assigned=true
                                used_networks="$used_networks $network"
                            else # Если WAN уже назначен, выдаем OPT
                                echo "$(date) [context] Duplicate WAN request for $iface (MAC=$ctx_mac) — assigning OPT" >> "$LOG"
                                candidate="opt$next_opt"
                                # Ищем свободный OPT
                                while echo "$used_networks" | tr ' ' '\n' | grep -qx "$candidate"; do
                                    next_opt=$((next_opt + 1))
                                    candidate="opt$next_opt"
                                done
                                network="$candidate"
                                used_networks="$used_networks $network"
                                next_opt=$((next_opt + 1))
                                desc="$(echo "$network" | tr '[:lower:]' '[:upper:]')"
                            fi
                            ;;
                        opt[0-9]*)
                            # Запрос OPTx
                            candidate="$lower_type"
                            if echo "$used_networks" | tr ' ' '\n' | grep -qx "$candidate"; then
                                candidate="opt$next_opt"
                                # Ищем свободный OPT
                                while echo "$used_networks" | tr ' ' '\n' | grep -qx "$candidate"; do
                                    next_opt=$((next_opt + 1))
                                    candidate="opt$next_opt"
                                done
                                network="$candidate"
                                desc="$(echo "$network" | tr '[:lower:]' '[:upper:]')"
                                used_networks="$used_networks $network"
                                next_opt=$((next_opt + 1))
                            else # OPTx свободен, назначаем его
                                network="$candidate"
                                desc="$(echo "$network" | tr '[:lower:]' '[:upper:]')"
                                used_networks="$used_networks $network"
                                opt_index=$(echo "$candidate" | sed 's/^opt//')
                                # Обновляем next_opt, если нужно
                                if echo "$opt_index" | grep -Eq '^[0-9]+$'; then
                                    opt_index=$((opt_index + 1))
                                    if [ "$opt_index" -gt "$next_opt" ]; then
                                        next_opt="$opt_index"
                                    fi
                                fi
                            fi
                            ;;
                        *)
                            # Неизвестный тип — выдаем OPT
                            candidate="opt$next_opt"
                            # Ищем свободный OPT
                            while echo "$used_networks" | tr ' ' '\n' | grep -qx "$candidate"; do
                                next_opt=$((next_opt + 1))
                                candidate="opt$next_opt"
                            done
                            network="$candidate"
                            used_networks="$used_networks $network"
                            next_opt=$((next_opt + 1))
                            desc="$(echo "$network" | tr '[:lower:]' '[:upper:]')"
                            ;;
                    esac 
                else # Тип не указан — выдаем следующий свободный OPT
                    candidate="opt$next_opt"
                    # Ищем свободный OPT
                    while echo "$used_networks" | tr ' ' '\n' | grep -qx "$candidate"; do
                        next_opt=$((next_opt + 1))
                        candidate="opt$next_opt"
                    done
                    network="$candidate"
                    used_networks="$used_networks $network"
                    next_opt=$((next_opt + 1))
                    desc="$(echo "$network" | tr '[:lower:]' '[:upper:]')"
                fi
                # Конфигурируем интерфейс
                if [ -n "$ip_addr" ] && [ -n "$mask" ]; then
                    prefix=$(php -r "echo substr_count(decbin(ip2long('$mask')), '1');")
                    ifconfig "$iface" inet "$ip_addr" netmask "$mask" description "$desc"
                    ifconfig "$iface" ether "$ctx_mac"
                    echo "$(date) [context] Added $iface → $desc ($ip_addr/$prefix)" >> "$LOG"
                    added_if_count=$((added_if_count + 1))
                    # Добавляем интерфейс в config.xml
                    xml ed -L \
                        -s "//interfaces" -t elem -n "$network" -v "" \
                        -s "//interfaces/$network" -t elem -n "descr" -v "$desc" \
                        -s "//interfaces/$network" -t elem -n "enable" -v "YES" \
                        -s "//interfaces/$network" -t elem -n "ipaddr" -v "$ip_addr" \
                        -s "//interfaces/$network" -t elem -n "if" -v "$iface" \
                        -s "//interfaces/$network" -t elem -n "spoofmac" -v "$ctx_mac" \
                        -s "//interfaces/$network" -t elem -n "subnet" -v "$prefix" \
                        "$backup_xml_file"
                    # Защита от проблем с XML-парсером pfSense (CDATA и пустой enable)  
                    sed -i '' \
                        -e "s|<descr>$desc</descr>|<descr><![CDATA[$desc]]></descr>|g" \
                        -e 's|<enable>YES</enable>|<enable></enable>|g' \
                        "$backup_xml_file"
                    if [ "$network" = "wan" ] && [ -n "$gw" ]; then
                      WAN_GATEWAY="$gw"
                    fi
                fi
            fi
        done
    done
fi
echo "$(date) [context] Total interfaces configured: $added_if_count" >> "$LOG"
# --- /СЕТИ ---------------------------------------------------------------
# DNS (берем из всех ETHx_DNS, если указаны)
# Собираем все DNS в одну строку
all_dns=$(set | grep -oE '^ETH[0-9]+_DNS' | sort -u | while read -r var; do eval "echo \${$var:-}"; done | xargs)
if [ -n "$all_dns" ]; then # Если есть хотя бы один DNS
    # Берем первый и последний из списка
    dns1=$(echo "$all_dns" | awk '{print $1}')
    dns2=$(echo "$all_dns" | awk '{print $NF}')
    # Обновляем /etc/resolv.conf
    echo "$(date) [context] Setting DNS: $dns1 $dns2" >> "$LOG"
    : > /etc/resolv.conf
    [ -n "$dns1" ] && echo "nameserver $dns1" >> /etc/resolv.conf
    [ -n "$dns2" ] && echo "nameserver $dns2" >> /etc/resolv.conf
    # Обновляем DNS в config.xml (если указаны)
    xml ed -L \
        -u "//system/dnsserver[1]" -v "$dns1" \
        -u "//system/dnsserver[2]" -v "$dns2" \
        -u "//system/dnsallowoverride" -v "" \
        "$backup_xml_file"
    echo "$(date) [context] Set DNS: $dns1 $dns2" >> "$LOG"
fi
# Hostname (если указана переменная SET_HOSTNAME)
if [ -n "${SET_HOSTNAME:-}" ]; then
    hostname "$SET_HOSTNAME"
    xml ed -L -u "//system/hostname" -v "$SET_HOSTNAME" "$backup_xml_file"
    echo "$(date) [context] Set hostname: $SET_HOSTNAME" >> "$LOG"
fi
# --- Password override logic ---
if [ -n "${PASSWORD_ROOT}" ]; then
    PASSWORD="${PASSWORD_ROOT}"
    echo "$(date) [context] PASSWORD_ROOT detected → override PASSWORD" >> "$LOG"
fi
# Пароль admin (через playback)
old_hash=$(xml sel -t -m "//user[name='admin']" -v "bcrypt-hash" -n "$backup_xml_file")
if php -r "exit(password_verify('${PASSWORD:-}', '$old_hash') ? 0 : 1);"; then
    echo "$(date) [context] Admin password unchanged" >> "$LOG"
else
     if pfSsh.php playback ChangePassTool admin "${PASSWORD:-}" >> "$LOG" 2>&1; then
        echo "$(date) [context] Admin password changed" >> "$LOG"
        new_hash=$(xml sel -t -m "//user[name='admin']" -v "bcrypt-hash" -n "$xml_file" 2>/dev/null || true)
        if [ -n "$new_hash" ]; then
            xml ed -L -u "//user[name='admin']/bcrypt-hash" -v "$new_hash" "$backup_xml_file"
            echo "$(date) [context] Synced admin bcrypt-hash into backup XML" >> "$LOG"
        else
            echo "$(date) [context] Warning: unable to read new admin bcrypt-hash for backup XML sync" >> "$LOG"
        fi
    else
        echo "$(date) [context] ERROR: failed to change admin password via ChangePassTool" >> "$LOG"
    fi
fi
# получаем шлюз WAN из контекстных переменных по MAC адресу интерфейса WAN 
for ifeth in $(ifconfig -l); do
    eth_mac=$(ifconfig "$ifeth" | awk '/ether/ {print $2}')
    [ -n "$eth_mac" ] || continue
    if ifconfig "$ifeth" | grep -q 'description: WAN' ; then
        echo "$(date) [context] Found WAN interface $ifeth (MAC=$eth_mac)" >> "$LOG"
        eth=$(set | grep "ETH" | grep -i "$eth_mac" | cut -d "_" -f 1 )
        WAN_GATEWAY=$(set | grep "$eth""_GATEWAY=" | cut -d "=" -f 2 | tr -d '"')
        echo "$(date) [context] Detected WAN_GATEWAY=$WAN_GATEWAY from $eth" >> "$LOG"
    fi
done
# Проверяем текущий шлюз по умолчанию 
current_gw=$(netstat -rn | awk '/^0.0.0.0/ {print $2; exit}') 
if [ -n "$WAN_GATEWAY" ]; then
    network="wan"
    sleep 0.2
    if [ "$current_gw" != "$WAN_GATEWAY" ]; then # Меняем шлюз, только если он отличается от текущего 
        { echo "$(date) [context] Current default gateway: ${current_gw:-"(none)"} differs from desired: $WAN_GATEWAY — updating route (BGP off)" 
          route delete default 
          route add default "$WAN_GATEWAY" 
        } >> "$LOG" 2>&1
        # --- Проверяем, есть ли секция <gateways> ---
        if ! xml sel -t -v "//gateways" "$backup_xml_file" >/dev/null 2>&1; then
            echo "$(date) [context] Gateways section missing — creating one" >> "$LOG"
            xml ed -L -s "//pfsense" -t elem -n "gateways" -v "" "$backup_xml_file"
        fi
        # Удаляем возможный старый шлюз перед добавлением нового
        xml ed -L -d "//gateways/gateway_item[name='WANGW']" "$backup_xml_file"
        xml ed -L -d "//interfaces//gateway[text()='WANGW']" "$backup_xml_file"
        xml ed -L -d "//gateways/defaultgw4[text()='WANGW']" "$backup_xml_file"
        # Добавляем шлюз в config.xml
        xml ed -L \
            -s "//gateways" -t elem -n "gateway_item" -v "" \
            -s "//gateways/gateway_item[last()]" -t elem -n "interface" -v "$network" \
            -s "//gateways/gateway_item[last()]" -t elem -n "gateway" -v "$WAN_GATEWAY" \
            -s "//gateways/gateway_item[last()]" -t elem -n "name" -v "WANGW" \
            -s "//gateways/gateway_item[last()]" -t elem -n "descr" -v "Default IPv4 Gateway" \
            -s "//gateways/gateway_item[last()]" -t elem -n "defaultgw4" -v "yes" \
            -s "//gateways/gateway_item[last()]" -t elem -n "weight" -v "1" \
            -u "//gateways/defaultgw4" -v "WANGW" \
            "$backup_xml_file"
        # Привязываем шлюз WANGW к интерфейсу WAN, если его нет
            xml ed -L -s "//interfaces/$network" -t elem -n "gateway" -v "WANGW" "$backup_xml_file"
            echo "$(date) [context] Added gateway WANGW to $network" >> "$LOG"
    elif [ "$current_gw" = "$WAN_GATEWAY" ]; then # Шлюз уже установлен и совпадает с нужным 
        echo "$(date) [context] Current default gateway: $current_gw matches desired: $WAN_GATEWAY — no change needed" >> "$LOG"
    fi
fi
# Если BGP включен, удаляем маршрут по умолчанию, чтобы BGP управлял маршрутом
# BGP_ENABLE=YES|NO (по умолчанию NO)
if [ "${BGP_ENABLE}" = "YES" ] ; then # Если BGP включен, то удаляем маршрут
    echo "$(date) [context] BGP is enabled, removing default route: $WAN_GATEWAY because BGP will manage it" >> "$LOG"
    route delete default >/dev/null 2>&1
    # Удаляем старый шлюз из config.xml, если он есть
    xml ed -L -d "//gateways/gateway_item[name='WANGW']" "$backup_xml_file"
    xml ed -L -d "//interfaces//gateway[text()='WANGW']" "$backup_xml_file"
    xml ed -L -d "//gateways/defaultgw4[text()='WANGW']" "$backup_xml_file"
fi
# Отключаем/Включаем private networks для WAN
if [ -n "$BLOCK_PRIVATE_NETWORKS" ] && [ "$BLOCK_PRIVATE_NETWORKS" = "on" ]; then
     xml ed -L \
        -s "//interfaces/$network" -t elem -n "blockpriv" -v "" \
        "$backup_xml_file"
    echo "$(date) [context] BLOCK_PRIVATE_NETWORKS" >> "$LOG"
else
    xml ed -L \
        -d "//interfaces/$network/blockpriv" \
        "$backup_xml_file"
    echo "$(date) [context] No BLOCK_PRIVATE_NETWORKS" >> "$LOG"
fi
# Отключаем/Включаем bogon networks для WAN
if [ -n "$BLOCK_BOGON_NETWORKS" ] && [ "$BLOCK_BOGON_NETWORKS" = "on" ]; then
    xml ed -L \
        -s "//interfaces/$network" -t elem -n "blockbogons" -v "" \
        "$backup_xml_file"
    echo "$(date) [context-network] BLOCK_BOGON_NETWORKS" >> "$LOG"
else
    xml ed -L \
        -d "//interfaces/$network/blockbogons" \
        "$backup_xml_file"
    echo "$(date) [context] No BLOCK_BOGON_NETWORKS" >> "$LOG"
fi
# Синхронизация config.xml (если есть изменения)
if diff -I '<bcrypt-hash>.*</bcrypt-hash>'  -I '<authorizedkeys>.*</authorizedkeys>' -q "$xml_file" "$backup_xml_file" >/dev/null; then
    rm -f "$backup_xml_file"
    echo "$(date) [context] No changes in config.xml, backup_xml_file removed" >> "$LOG"
elif [ -s "$backup_xml_file" ]; then # Если файл не пустой, копируем его в config.xml
    cp "$backup_xml_file" "$xml_file"
    echo "$(date) [context] config.xml updated, backup_xml_file saved to $backup_xml_file" >> "$LOG"
fi
# Если есть изменения в секции interfaces, ставим флаг на перезагрузку интерфейсов
# RC_RELOAD_IFACE=on|off (по умолчанию off)
hash1="$(xml sel -t -c "//interfaces" "$xml_file" | xml fo -n -o | tr -d '\n' | md5)"
cp "$xml_file" "/root/xml_file"
cp "$backup_xml_file" "/root/backup_xml_file"
hash2="$(xml sel -t -c "//interfaces" "$backup_xml_file" | xml fo -n -o | tr -d '\n' | md5)"
if [ "$hash1" != "$hash2" ]; then
   { echo "$(date) [context] Interfaces section changed, need to reload interfaces set RC_RELOAD_IFACE=on"
     echo "$(date) [context] Old interfaces config hash: $hash1"
     echo "$(date) [context] New interfaces config hash: $hash2"
    }>> "$LOG"
    RC_RELOAD_IFACE="on"
fi
# Перезагрузка служб pfSense (если указано в контексте)
if [ "${RC_RELOAD_ALL}" = "on" ]; then
    # Перезагружаем службы pfSense
   {    /etc/rc.reload_all start
        echo "$(date) [context] pfSense services reloaded"
        pfSsh.php playback restartallwan
        echo "$(date) [context] pfSense services restarted"
    } >>"$LOG" 2>&1
fi
# Перезагрузка интерфейсов pfSense (если указано в контексте)
if [ "${RC_RELOAD_IFACE}" = "on" ]; then
    echo "$(date) [context]  ${RC_RELOAD_IFACE} or PID file detected $PID" 
    # Перезагружаем интерфейсы pfSense
    {   pfSsh.php playback restartallwan
        echo "$(date) [context] pfSense services restarted"
    } >>"$LOG" 2>&1
fi
# --- FIREWALL -------------------------------------------------------------
# отключение/включение pfSense firewall (pfctl) 
echo "$(date) [context] pfSense firewall switch = ${PFCTL}" >> "$LOG"
if [ -n "${PFCTL:-}" ]; then # если переменная PFCTL указана
    # Приводим значение к нижнему регистру для удобства сравнения   
    _lc_pfctl=$(echo "${PFCTL}" | tr '[:upper:]' '[:lower:]')
    case "$_lc_pfctl" in
        no|0)
            {
                if pfctl -s info 2>/dev/null | grep -qi 'Status: Enabled'; then
                    pfctl -d
                    echo "$(date) [context] pfSense firewall disabled"
                else
                    echo "$(date) [context] pfSense firewall already disabled (pf not enabled)"
                fi
                echo "$$" > /var/run/pfctlcontext.pid
                echo "$(date) [context] Created pid file: /var/run/pfctlcontext.pid"
            } >> "$LOG" 2>&1
            ;;
        yes|1)
            if pfctl -s info | grep -qi 'Status: Disabled'; then
                {
                    echo "$(date) [context] pfSense firewall was disabled, enabling now '${PFCTL}'"
                    rm -rf /var/run/pfctlcontext.pid
                    echo "$(date) [context] Removed pid file: /var/run/pfctlcontext.pid"
                    pfctl -e
                    echo "$(date) [context] pfSense firewall enabled"
                } >> "$LOG" 2>&1
            fi
            ;;
        *)
            echo "$(date) [context] pfSense firewall state unchanged (PFCTL=$_lc_pfctl)" >> "$LOG"
            ;;
    esac
fi
# Отмонтировать диск после выполнения всех операций
if mount | grep -q "on $CONTEXT_MOUNT "; then
    umount "$CONTEXT_MOUNT" && echo "$(date) [context] Unmounted $CONTEXT_MOUNT" >> "$LOG"
else
    echo "$(date) [context] $CONTEXT_MOUNT already unmounted" >> "$LOG"
fi
# --- ДОПОЛНИТЕЛЬНЫЕ МОДУЛИ ------------------------------------------------
# BGP-модуль 
if [ -x /etc/context.d/modules/bgp ]; then
    echo "$(date) [context] Running BGP module /etc/context.d/modules/bgp" >> "$LOG"
     # shellcheck disable=SC1091
    . /etc/context.d/modules/bgp
    echo "$(date) [context] BGP module (return $?)" >> "$LOG"
fi

# SSH ключ (если указана переменная SSH_PUBLIC_KEY)
if [ -n "${SSH_PUBLIC_KEY:-}" ]; then
    mkdir -p /root/.ssh
    if [ ! -f /root/.ssh/authorized_keys ] || ! grep -Fxq "$SSH_PUBLIC_KEY" /root/.ssh/authorized_keys; then
        # кодируем ключ в base64 (без переносов строк)
        # pfSense stores SSH authorized keys in base64 format inside <authorizedkeys>
        # This ensures compatibility with pfSense GUI and PHP auth subsystem.
        ENC_KEY=$(printf '%s' "$SSH_PUBLIC_KEY" | base64 | tr -d '\n')
        if xml sel -t -v "//user[name='admin']/authorizedkeys" "$xml_file" >/dev/null 2>&1; then
            xml ed -L -u "//user[name='admin']/authorizedkeys" -v "$ENC_KEY" "$xml_file"
        else
            xml ed -L -s "//user[name='admin']" -t elem -n "authorizedkeys" -v "$ENC_KEY" "$xml_file"
        fi
        echo "$(date) [context] SSH public key updated in config.xml" >> "$LOG"
        echo "$SSH_PUBLIC_KEY" >> /root/.ssh/authorized_keys
        chmod 600 /root/.ssh/authorized_keys
        chmod 700 /root/.ssh
        echo "$(date) [context] SSH public key updated" >> "$LOG"
        #RC_RELOAD_ALL="on" && echo "$(date) [context] RC_RELOAD_ALL set to on due to SSH key change" >> "$LOG"
    fi
fi

# Модуль управления management-интерфейсом
MGMT_MODULE="/etc/context.d/modules/mgmt.sh"
if [ -x "$MGMT_MODULE" ]; then
    echo "$(date) [context] Running MGMT module $MGMT_MODULE (MGMT_ENABLE=${MGMT_ENABLE})" >> "$LOG"
    export MGMT_ENABLE MGMT_IF MGMT_PORT
    # shellcheck disable=SC1090
    . "$MGMT_MODULE" >>"$LOG" 2>&1
    status=$?
    if [ $status -eq 0 ]; then
        echo "$(date) [context-MGMT:ContextOnly] module finished successfully" >> "$LOG"
    else
        echo "$(date) [context-MGMT:ContextOnly] MGMT module failed (exit $status)" >> "$LOG"
    fi
fi
if [ -f "$PID" ]; then
    {
        echo "$(date) [context] Файл найден: $PID = cat $PID" 
        rm -f "$(date) [context] $PID" && echo "Файл $PID удалён."
    } >> "$LOG"
fi
echo "$(date) [context] FINISH" >> "$LOG"