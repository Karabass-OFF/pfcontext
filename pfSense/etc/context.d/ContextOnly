#!/bin/sh
#
# Add the following line to /cf/conf/config.xml to enable this service:
# add in /cf/conf/config.xml section "<system>"  line <earlyshellcmd>/etc/rc.d/context onestart</earlyshellcmd>
# PROVIDE: context
# REQUIRE: NETWORK netif routing
# KEYWORD: shutdown
#
PATH=/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin:/root/bin
# FreeBSD rc.subr (used below) may reference the internal helper `_rc_svcj`
# while loading, and when the script is launched directly with `onestart`
# under `set -u` semantics the variable being unset raises a fatal error.
# Prime it before sourcing rc.subr so the include never faults.
: "${_rc_svcj:=}"

# shellcheck source=/dev/null
. /etc/rc.subr

name="context"
desc="OpenNebula: context script executor"
# shellcheck disable=SC2034
rcvar="context_enable"

load_rc_config $name
: "${context_enable:=NO}"
# shellcheck disable=SC2034
extra_commands="status stop"

LOG="/tmp/context.log"
#LOG="/dev/null" # Uncomment for debugging
CONTEXT_MOUNT="/mnt/context"
PID="/etc/context.d/net.pid"
CONTEXT_DEV="/dev/cd0"
CONTEXT_FILE="$CONTEXT_MOUNT/context.sh"
xml_file="/cf/conf/config.xml"
backup_xml_file="/cf/conf/backup/config.xml.$(date +%Y.%m.%d.%H:%M:%S)"
# shellcheck disable=SC2034
start_cmd="${name}_start"
# shellcheck disable=SC2034
stop_cmd="${name}_stop"
# shellcheck disable=SC2034
status_cmd="${name}_status"

context_log() {
    printf '%s [context] %s\n' "$(date)" "$*" >> "$LOG"
}

lowercase() {
    printf '%s' "$1" | tr '[:upper:]' '[:lower:]'
}

uppercase() {
    printf '%s' "$1" | tr '[:lower:]' '[:upper:]'
}

normalize_mac() {
    lowercase "${1:-}"
}

slot_in_use() {
    case " $used_networks " in
        *" $1 "*) return 0 ;;
    esac
    return 1
}

mark_slot() {
    used_networks="$used_networks$1 "
}

next_free_opt() {
    while slot_in_use "opt$next_opt"; do
        next_opt=$((next_opt + 1))
    done
    printf 'opt%s' "$next_opt"
}

slot_desc() {
    case "$1" in
        lan) printf 'LAN' ;;
        wan) printf 'WAN' ;;
        opt*) uppercase "$1" ;;
        *) uppercase "$1" ;;
    esac
}

is_private_ip() {
    case "${1:-}" in
        10.*|192.168.*|172.1[6-9].*|172.2[0-9].*|172.3[0-1].*) return 0 ;;
    esac
    return 1
}

context_start() {
    context_log "=== START ContextOnly $(date) ==="

    mkdir -p "$CONTEXT_MOUNT"
    if ! mount | grep -q "on $CONTEXT_MOUNT "; then
        mount -t cd9660 "$CONTEXT_DEV" "$CONTEXT_MOUNT" >> "$LOG" 2>&1
    fi

    if [ ! -f "$CONTEXT_FILE" ]; then
        context_log "$CONTEXT_FILE not found, exiting"
        return 0
    fi

    context_log "Found $CONTEXT_FILE — sourcing"
    # shellcheck source=/dev/null
    . "$CONTEXT_FILE"
    cp "$xml_file" "$backup_xml_file"

    get_ctx_var() {
        idx="$1"
        suffix="$2"
        val=""
        eval "val=\${ETH${idx}_${suffix}:-}"
        if [ -z "${val:-}" ]; then
            eval "val=\${ETHERNET${idx}_${suffix}:-}"
        fi
        printf '%s' "${val:-}"
    }

    ctx_indices=$(set | sed -n 's/^ETHERNET\([0-9][0-9]*\)_MAC=.*/\1/p; s/^ETH\([0-9][0-9]*\)_MAC=.*/\1/p' | sort -n | uniq)
    if [ -n "$ctx_indices" ]; then
        ctx_if_count=$(printf '%s\n' "$ctx_indices" | sed '/^$/d' | wc -l | awk '{print $1}')
    else
        ctx_if_count=0
    fi

    ctx_mac_map=""
    for idx in $ctx_indices; do
        ctx_mac=$(get_ctx_var "$idx" "MAC")
        [ -n "$ctx_mac" ] || continue
        ctx_mac_map="$ctx_mac_map $(normalize_mac "$ctx_mac"):$idx"
    done

    sys_ifaces=$(ifconfig -l)
    sys_mac_map=""
    for iface in $sys_ifaces; do
        sys_mac=$(ifconfig "$iface" | awk '/ether/{print $2}')
        [ -n "$sys_mac" ] || continue
        sys_mac_map="$sys_mac_map $iface:$(normalize_mac "$sys_mac")"
    done

    find_iface_by_mac() {
        target=$(normalize_mac "$1")
        for entry in $sys_mac_map; do
            iface=${entry%%:*}
            mac=${entry#*:}
            if [ "$mac" = "$target" ]; then
                printf '%s' "$iface"
                return 0
            fi
        done
        return 1
    }

    ctx_idx_for_mac() {
        target=$(normalize_mac "$1")
        for entry in $ctx_mac_map; do
            mac=${entry%%:*}
            idx=${entry#*:}
            if [ "$mac" = "$target" ]; then
                printf '%s' "$idx"
                return 0
            fi
        done
        return 1
    }

    sys_mac_for_iface() {
        target="$1"
        for entry in $sys_mac_map; do
            iface=${entry%%:*}
            mac=${entry#*:}
            if [ "$iface" = "$target" ]; then
                printf '%s' "$mac"
                return 0
            fi
        done
        return 1
    }

    ensure_ssh_key() {
        [ -n "${SSH_PUBLIC_KEY:-}" ] || return 0
        mkdir -p /root/.ssh
        auth=/root/.ssh/authorized_keys
        if [ ! -f "$auth" ] || ! grep -Fxq "$SSH_PUBLIC_KEY" "$auth"; then
            printf '%s\n' "$SSH_PUBLIC_KEY" >> "$auth"
            chmod 600 "$auth"
            chmod 700 /root/.ssh
            context_log "SSH public key updated"
        fi
    }

    ensure_ssh_key

    iface_type_changed=false
    added_if_count=0

    xml_if_count=$(xml sel -t -v "count(//interfaces/*)" "$xml_file" 2>/dev/null || echo 0)
    if [ "$ctx_if_count" -gt "$xml_if_count" ]; then
        iface_type_changed=true
        context_log "Detected $ctx_if_count ETHx entries > $xml_if_count XML entries — rebuild required"
    fi

    for entry in $sys_mac_map; do
        iface=${entry%%:*}
        mac=${entry#*:}
        idx=$(ctx_idx_for_mac "$mac") || continue
        want_type=$(get_ctx_var "$idx" "TYPE")
        [ -n "$want_type" ] || continue

        current_descr=$(ifconfig "$iface" | awk -F: '/description/{print $2}' | xargs)
        case $(lowercase "$want_type") in
            lan) want_descr="LAN" ;;
            wan) want_descr="WAN" ;;
            *)   want_descr=$(uppercase "$want_type") ;;
        esac
        if [ "$current_descr" != "$want_descr" ]; then
            real_mac=$(get_ctx_var "$idx" "MAC")
            want_label=$(uppercase "$want_type")
            context_log "${want_label:-TYPE} mismatch for $iface (MAC=${real_mac:-unknown}): want=$want_descr, have=${current_descr:-unset}"
            iface_type_changed=true
        fi
    done

    lan_pending=0
    wan_pending=0
    for idx in $ctx_indices; do
        want=$(get_ctx_var "$idx" "TYPE")
        [ -n "$want" ] || continue
        case $(lowercase "$want") in
            lan) lan_pending=$((lan_pending + 1)) ;;
            wan) wan_pending=$((wan_pending + 1)) ;;
        esac
    done

    lan_assigned=false
    wan_assigned=false
    next_opt=1
    used_networks=" "

    assign_slot() {
        iface="$1"
        ctx_mac="$2"
        ip="$3"
        mask="$4"
        want_type="$5"

        if [ -n "$want_type" ]; then
            lower=$(lowercase "$want_type")
            case "$lower" in
                lan)
                    [ "$lan_pending" -gt 0 ] && lan_pending=$((lan_pending - 1))
                    if [ "$lan_assigned" = false ]; then
                        lan_assigned=true
                        mark_slot lan
                        context_log "Manual type for $iface (MAC=$ctx_mac): lan"
                        printf 'lan|LAN'
                        return 0
                    fi
                    context_log "Duplicate LAN request for $iface (MAC=$ctx_mac) — assigning OPT"
                    ;;
                wan)
                    [ "$wan_pending" -gt 0 ] && wan_pending=$((wan_pending - 1))
                    if [ "$wan_assigned" = false ]; then
                        wan_assigned=true
                        mark_slot wan
                        context_log "Manual type for $iface (MAC=$ctx_mac): wan"
                        printf 'wan|WAN'
                        return 0
                    fi
                    context_log "Duplicate WAN request for $iface (MAC=$ctx_mac) — assigning OPT"
                    ;;
                opt[0-9]*)
                    candidate="$lower"
                    if slot_in_use "$candidate"; then
                        context_log "Requested slot $candidate for $iface (MAC=$ctx_mac) already in use — assigning OPT"
                    else
                        mark_slot "$candidate"
                        opt_index=${candidate#opt}
                        if printf '%s' "$opt_index" | grep -Eq '^[0-9]+$'; then
                            opt_index=$((opt_index + 1))
                            if [ "$opt_index" -gt "$next_opt" ]; then
                                next_opt="$opt_index"
                            fi
                        fi
                        printf '%s|%s' "$candidate" "$(slot_desc "$candidate")"
                        return 0
                    fi
                    ;;
                *)
                    context_log "Unknown type '$want_type' for $iface (MAC=$ctx_mac) — assigning OPT"
                    ;;
            esac
        fi

        if [ -n "$ip" ] && is_private_ip "$ip" && [ "$lan_assigned" = false ] && [ "$lan_pending" -eq 0 ]; then
            lan_assigned=true
            mark_slot lan
            printf 'lan|LAN'
            return 0
        fi

        if [ -n "$ip" ] && ! is_private_ip "$ip" && [ "$wan_assigned" = false ] && [ "$wan_pending" -eq 0 ]; then
            wan_assigned=true
            mark_slot wan
            gw_note=""
            [ -n "${gw:-}" ] && gw_note=" GW:$gw"
            context_log "Detected WAN interface: $iface ($ctx_mac) ${ip}/${mask}${gw_note}"
            printf 'wan|WAN'
            return 0
        fi

        candidate=$(next_free_opt)
        mark_slot "$candidate"
        next_opt=$((next_opt + 1))
        printf '%s|%s' "$candidate" "$(slot_desc "$candidate")"
    }

    if [ -f "$PID" ] || [ "$iface_type_changed" = true ]; then
        xml ed -L -d "//interfaces/*" "$backup_xml_file"

        for iface in $sys_ifaces; do
            sys_mac=$(sys_mac_for_iface "$iface") || continue
            idx=$(ctx_idx_for_mac "$sys_mac") || continue

            ctx_mac=$(get_ctx_var "$idx" "MAC")
            ip_addr=$(get_ctx_var "$idx" "IP")
            mask=$(get_ctx_var "$idx" "MASK")
            gw=$(get_ctx_var "$idx" "GATEWAY")
            iface_type=$(get_ctx_var "$idx" "TYPE")
            dhcp_start=$(get_ctx_var "$idx" "DHCP_START")
            dhcp_end=$(get_ctx_var "$idx" "DHCP_END")

            slot_info=$(assign_slot "$iface" "$ctx_mac" "$ip_addr" "$mask" "$iface_type")
            network=${slot_info%%|*}
            desc=${slot_info#*|}

            [ -n "$ip_addr" ] && [ -n "$mask" ] || continue

            prefix=$(php -r "echo substr_count(decbin(ip2long('$mask')), '1');")
            ifconfig "$iface" inet "$ip_addr" netmask "$mask" description "$desc"
            ifconfig "$iface" ether "$ctx_mac"
            context_log "Added $iface → $desc (${ip_addr}/${prefix})"
            added_if_count=$((added_if_count + 1))

            xml ed -L \
                -s "//interfaces" -t elem -n "$network" -v "" \
                -s "//interfaces/$network" -t elem -n "descr" -v "$desc" \
                -s "//interfaces/$network" -t elem -n "enable" -v "YES" \
                -s "//interfaces/$network" -t elem -n "ipaddr" -v "$ip_addr" \
                -s "//interfaces/$network" -t elem -n "if" -v "$iface" \
                -s "//interfaces/$network" -t elem -n "spoofmac" -v "$ctx_mac" \
                -s "//interfaces/$network" -t elem -n "subnet" -v "$prefix" \
                "$backup_xml_file"

            sed -i '' \
                -e "s|<descr>$desc</descr>|<descr><![CDATA[$desc]]></descr>|g" \
                -e 's|<enable>YES</enable>|<enable></enable>|g' \
                "$backup_xml_file"

            if [ -n "$dhcp_start" ] && [ -n "$dhcp_end" ]; then
                if ! xml sel -t -v "count(//dhcpd)" "$backup_xml_file" 2>/dev/null | grep -q '[1-9]'; then
                    xml ed -L -s "//config" -t elem -n "dhcpd" -v "" "$backup_xml_file"
                fi
                xml ed -L \
                    -s "//dhcpd" -t elem -n "$network" -v "" \
                    -s "//dhcpd/$network" -t elem -n "range" -v "" \
                    -s "//dhcpd/$network/range" -t elem -n "from" -v "$dhcp_start" \
                    -s "//dhcpd/$network/range" -t elem -n "to" -v "$dhcp_end" \
                    -s "//dhcpd/$network" -t elem -n "enable" -v "" \
                    "$backup_xml_file"
            else
                xml ed -L -d "//dhcpd/$network" "$backup_xml_file" 2>/dev/null
            fi

            if [ "$network" = "wan" ] && [ -n "$gw" ]; then
                route delete default >/dev/null 2>&1
                route add default "$gw"
                xml ed -L \
                    -s "//interfaces/$network" -t elem -n "blockpriv" -v "" \
                    -s "//interfaces/$network" -t elem -n "blockbogons" -v "" \
                    "$backup_xml_file"
                xml ed -L \
                    -d "//system/gateway" \
                    -s "//system" -t elem -n "gateway" -v "$gw" \
                    -s "//interfaces/$network" -t elem -n "gateway" -v "WANGW" \
                    "$backup_xml_file"
                context_log "Gateway: $gw"
            fi
        done
    fi

    context_log "Total interfaces configured: $added_if_count"

    dns_list=""
    for idx in $ctx_indices; do
        dns_val=$(get_ctx_var "$idx" "DNS")
        [ -n "$dns_val" ] || continue
        for token in $dns_val; do
            [ -n "$token" ] || continue
            dns_list="$dns_list $token"
        done
    done
    all_dns=$(printf '%s\n' "$dns_list" | awk '{$1=$1; print}')
    if [ -n "$all_dns" ]; then
        dns1=$(echo "$all_dns" | awk '{print $1}')
        dns2=$(echo "$all_dns" | awk '{print $NF}')
        : > /etc/resolv.conf
        [ -n "$dns1" ] && printf 'nameserver %s\n' "$dns1" >> /etc/resolv.conf
        [ -n "$dns2" ] && printf 'nameserver %s\n' "$dns2" >> /etc/resolv.conf

        xml ed -L \
            -u "//system/dnsserver[1]" -v "$dns1" \
            -u "//system/dnsserver[2]" -v "$dns2" \
            -u "//system/dnsallowoverride" -v "" \
            "$backup_xml_file"
        context_log "Set DNS: $dns1 $dns2"
    fi

    if [ -n "${SET_HOSTNAME:-}" ]; then
        hostname "$SET_HOSTNAME"
        xml ed -L -u "//system/hostname" -v "$SET_HOSTNAME" "$backup_xml_file"
        context_log "Set hostname: $SET_HOSTNAME"
    fi

    if diff -I '<bcrypt-hash>.*</bcrypt-hash>' -q "$xml_file" "$backup_xml_file" >/dev/null; then
        rm -f "$backup_xml_file"
        context_log "No changes in config.xml, backup_xml_file removed"
    elif [ -s "$backup_xml_file" ]; then
        cp "$backup_xml_file" "$xml_file"
        context_log "config.xml updated, backup_xml_file saved to $backup_xml_file"
        /etc/rc.reload_all start >> "$LOG" 2>&1
        context_log "pfSense services reloaded"
        pfSsh.php playback restartallwan >> "$LOG" 2>&1
        context_log "pfSense services restarted"
    fi

    if [ -n "${PFCTL:-}" ]; then
        _lc_pfctl=$(lowercase "${PFCTL}")
        case "$_lc_pfctl" in
            off|0|false|disabled)
                pfctl -d >> "$LOG" 2>&1
                context_log "pfSense firewall disabled"
                ;;
            on|1|true|enabled)
                if pfctl -s info | grep -q 'Status: Disabled'; then
                    context_log "pfSense firewall was disabled, enabling now"
                    pfctl -e >> "$LOG" 2>&1
                    context_log "pfSense firewall enabled"
                fi
                ;;
            *)
                context_log "pfSense firewall state unchanged (PFCTL=$_lc_pfctl)"
                ;;
        esac
    fi

    old_hash=$(xml sel -t -m "//user[name='admin']" -v "bcrypt-hash" -n "$xml_file")
    if php -r "exit(password_verify('${PASSWORD:-}', '$old_hash') ? 0 : 1);"; then
        context_log "Admin password unchanged"
    else
        pfSsh.php playback ChangePassTool admin "${PASSWORD:-}" >> "$LOG" 2>&1
        context_log "Admin password changed"
    fi

    if mount | grep -q "on $CONTEXT_MOUNT "; then
        umount "$CONTEXT_MOUNT" && context_log "Unmounted $CONTEXT_MOUNT"
    else
        context_log "$CONTEXT_MOUNT already unmounted"
    fi

    if [ -x /etc/context.d/bgp ]; then
        context_log "Running BGP module /etc/context.d/bgp"
        if . /etc/context.d/bgp >> "$LOG" 2>&1; then
            context_log "BGP module completed"
        else
            rc=$?
            context_log "BGP module failed (exit $rc)"
        fi
    fi

    ensure_ssh_key

    if [ -f "$PID" ] || [ "$iface_type_changed" = true ]; then
        /etc/rc.reload_all start >> "$LOG" 2>&1
        rm -f "$PID"
    fi
    context_log "FINISH"
}

run_rc_command "$1"
